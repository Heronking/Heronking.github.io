<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>这是个刚搭好的博客</title>
  <icon>https://www.gravatar.com/avatar/b23a4ea0e920b48f957291efdb1706bc</icon>
  <subtitle>弱小，可怜，无助</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heronking.gitee.io/"/>
  <updated>2020-04-06T14:05:12.193Z</updated>
  <id>https://heronking.gitee.io/</id>
  
  <author>
    <name>多喝热水会好的</name>
    <email>wangliuaaa@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://heronking.gitee.io/archives/97fc4ab0.html"/>
    <id>https://heronking.gitee.io/archives/97fc4ab0.html</id>
    <published>2020-04-06T13:06:57.000Z</published>
    <updated>2020-04-06T14:05:12.193Z</updated>
    
    <content type="html"><![CDATA[<p>根据遍历的结果来重建二叉树</p><p>知道<strong>中序和前序、中序和后序</strong>结果能确定一颗二叉树，而前序和后序不能，因为前序和后序只能确定父子关系，无法分辨左右子树。</p><p>现在来重建一下！</p><p>前序遍历序列{1,2,4,7,3,5,6,8}<br>中序遍历序列{4,7,2,1,5,3,8,6}</p><a id="more"></a><p>前序的第一节点是这棵树的根节点，在没有重复节点的情况下，我们在中序遍历的结果中找到它，它的左边就是根的左子树，右边是右子树。</p><p>所以这棵树就是这样了</p><img src="/archives/97fc4ab0/1.png" style="zoom:50%;"><p>然后对它的左右子树做同样的操作，找到根节点，拆分成左右子树，直到左右子树为空。</p><p>显然，这是个递归的过程。</p><p>上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到根节点的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pre   先序遍历序列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> preLeft   先序起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> preRight  先序终点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in    中序遍历序列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inLeft    中序起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inRight   中序终点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span>[] in, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode tree = <span class="keyword">new</span> TreeNode(pre[preLeft]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = inLeft; i &lt;= inRight; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == pre[preLeft]) &#123;</span><br><span class="line">            <span class="comment">//找左子树根节点，左子树长度是 i-left。</span></span><br><span class="line">            tree.left = findRoot(pre, preLeft+<span class="number">1</span>, preLeft+i-inLeft, in, inLeft, i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//找右子树根节点，右子树起点是左子树终点的后一个</span></span><br><span class="line">            tree.right = findRoot(pre, preLeft+i-inLeft+<span class="number">1</span>, preRight, in, i+<span class="number">1</span>, inRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每个子树的边界就行了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据遍历的结果来重建二叉树&lt;/p&gt;
&lt;p&gt;知道&lt;strong&gt;中序和前序、中序和后序&lt;/strong&gt;结果能确定一颗二叉树，而前序和后序不能，因为前序和后序只能确定父子关系，无法分辨左右子树。&lt;/p&gt;
&lt;p&gt;现在来重建一下！&lt;/p&gt;
&lt;p&gt;前序遍历序列{1,2,4,7,3,5,6,8}&lt;br&gt;中序遍历序列{4,7,2,1,5,3,8,6}&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://heronking.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="剑指offer" scheme="https://heronking.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://heronking.gitee.io/archives/de7c53fe.html"/>
    <id>https://heronking.gitee.io/archives/de7c53fe.html</id>
    <published>2020-04-05T05:48:40.000Z</published>
    <updated>2020-04-05T10:28:57.592Z</updated>
    
    <content type="html"><![CDATA[<p>当并发请求数量大而线程执行时间短的时候，使用常规的线程，就会出现频繁地创建和销毁。这样效率是极低的，服务器啥也不干就光在这创建销毁了，更别说还可能出现资源竞争。</p><p>于是java中就引进了线程池，顾名思义，就是创建一个属于线程的池子，来统一管理调配线程。线程池可以避免大量的线程强占资源，避免大量线程的创建和销毁带来的开销。</p><p>Executors类中提供了四种线程池，有对应的静态工厂来生成，然后实现ExecutorService接口来执行任务。</p><p>四种常用的线程池：</p><a id="more"></a><ul><li><code>FixedThreadPool</code> 固定长度线程池</li><li><code>SingleThreadPool</code> 单线程化线程池</li><li><code>CacheThreadPool</code> 可缓存线程池</li><li><code>ScheduledThreadPool</code> 周期性线程池</li></ul><h4 id="提交线程到线程池中的方法"><a href="#提交线程到线程池中的方法" class="headerlink" title="提交线程到线程池中的方法"></a>提交线程到线程池中的方法</h4><p><code>execute()</code> 方法：</p><p>在最上层的Executor接口中，<code>void execute(Runnable command);</code> 参数是一个Runnable对象，返回值为void，将Runnable任务提交到线程池。</p><p>所以 execute 方法无法获得执行结果，如果提交的任务抛出异常，那么execute会<strong>直接终止</strong>这个线程，在没有显示指定异常处理器的情况下，默认通过System.err打印错误。</p><p><code>submit()</code> 方法：</p><p>在ExecutorService接口中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">　　...</span><br><span class="line">　　&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">　　&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">　　Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">　　...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有三个方法，参数可以是Callable任务，也可以是Runnable任务。并且该方法会返回Future对象，代表的是线程的执行结果。使用submit方法提交的任务，可以捕获该任务抛出的异常，并将异常放到返回的Future对象中，<strong>不会终止线程</strong>，Future是一个接口。</p><p>调用 <code>Future.get()</code>方法能获取结果，<strong>该方法会产生阻塞</strong>，直到任务执行完毕才会返回结果。如果任务抛出异常，该方法会重新抛出这个异常，包装在 ExecutionException 中。</p><p>调用 <code>Future.cancle(boolean xxx)</code> 方法可以<strong>取消执行</strong>提交后的正在执行的任务！没有回滚的效果。</p><p>还有其他的<br> <code>isDone();//表示任务是否完成</code><br> <code>isCancelled();//任务是否取消成功</code><br> <code>get(long time, TImeUnit unit);//如果在指定时间time内没有获取到结果，就直接返回null</code></p><p>还有一种<code>FutureTask</code>类，它是Future接口的实现类，既可以作为Runnable线程被执行，也可以作为Future得到Callable的返回值。</p><h4 id="四种线程池的使用"><a href="#四种线程池的使用" class="headerlink" title="四种线程池的使用"></a>四种线程池的使用</h4><p>先写一个Callable线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始！！！"</span>);</span><br><span class="line"><span class="comment">//睡5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">//算个和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束！！！"</span>);</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一个创建线程池方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPool</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传一个线程池参数进来</span></span><br><span class="line">    ExecutorService service = executorService;</span><br><span class="line">    <span class="comment">//6个任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//任务放到线程中</span></span><br><span class="line">        FutureTask task = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">        <span class="comment">//提交到线程池</span></span><br><span class="line">        service.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法中：</p><h5 id="固定长度线程池"><a href="#固定长度线程池" class="headerlink" title="固定长度线程池"></a>固定长度线程池</h5><p><code>public static ExecutorService newFixedThreadPool(int nThreads)</code></p><p>该线程池的<strong>最大线程数</strong>为参数 nThreads。当任务数超过参数，超过部分会在一个无界队列中排队等待。也不是真的无界，请求队列的长度是 <code>Integer.MAX_VALUE</code> 。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是一个大小为3的线程池</span></span><br><span class="line">    threadPool(Executors.newFixedThreadPool(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3开始！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-2开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-2结束！！！</span><br><span class="line">pool-1-thread-3结束！！！</span><br><span class="line">pool-1-thread-2开始！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-3开始！！！</span><br><span class="line">pool-1-thread-2结束！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-3结束！！！</span><br></pre></td></tr></table></figure><p>可以看到，只创建了3个线程，超过的任务在等待线程释放，然后哪个线程有空就用哪个。实现了线程的复用。</p><p>当然，这个结果是特殊的，因为刚好123线程几乎同时结束，其他任务没有钻空子进来。</p><h5 id="单线程化线程池"><a href="#单线程化线程池" class="headerlink" title="单线程化线程池"></a>单线程化线程池</h5><p><code>public static ExecutorService newSingleThreadExecutor()</code></p><p>线程池中只有一个线程。当任务数超过1时，在无界队列中排队等待！</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">singleThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单线程化线程池</span></span><br><span class="line">    threadPool(Executors.newSingleThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br></pre></td></tr></table></figure><p>只使用一个线程来执行这6个任务</p><h5 id="可缓存线程池"><a href="#可缓存线程池" class="headerlink" title="可缓存线程池"></a>可缓存线程池</h5><p><code>public static ExecutorService newCachedThreadPool()</code></p><p>该线程池的最大线程数是 <code>Integer.MAX_VALUE</code> ，新的任务由空闲线程来执行，若没有空闲线程则在线程池中新建一个。如果一个线程空闲时间超过60秒，则自动销毁。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadPool(Executors.newCachedThreadPool());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>开始！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>开始！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>开始！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>开始！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>开始！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>开始！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>结束！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>结束！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>结束！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>结束！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>结束！！！</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>结束！！！</span><br></pre></td></tr></table></figure><p>创建了6个线程，主要是因为每个任务要运行5秒，任务提交得太快了。</p><h5 id="周期性线程池"><a href="#周期性线程池" class="headerlink" title="周期性线程池"></a>周期性线程池</h5><p><code>public static ExecutorService newScheduledThreadPool()</code></p><p>最大线程数为 <code>Integer.MAX_VALUE</code> ，可以创建指定长度的线程池，可以定时或者周期性地执行任务</p><p>使用：</p><p>延迟2s后，控制台才会打印输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程池大小为3</span></span><br><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">FutureTask task = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line"><span class="comment">//表示延迟2s后执行</span></span><br><span class="line">service.schedule(task, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure><p>延迟1s后，每过2s执行一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程池大小为3</span></span><br><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//表示延迟1s后，每割2s执行，该方法传入的是Runnable线程</span></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始！！"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"结束！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>注意的是，这里<strong>不能使用shutdown</strong>，关闭了就没有周期了。</p><p>再注意的是，这个周期是是<strong>以上一个任务开始的时间计时</strong>，2秒过去后，检测上一个任务是否执行完毕，如果上一个任务执行完毕，则当前任务立即执行。如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。</p><p>当然，还有<code>scheduleWithFixedDelay()</code>方法，是以上一个任务结束时开始计时的。</p><h5 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h5><p>注意，get方法会阻塞线程，直到当前任务执行完毕才会返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    FutureTask task = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());</span><br><span class="line">    service.submit(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看一下fixedThreadPool中的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">5050</span><br><span class="line">pool-1-thread-2开始！！！</span><br><span class="line">pool-1-thread-2结束！！！</span><br><span class="line">5050</span><br><span class="line">pool-1-thread-3开始！！！</span><br><span class="line">pool-1-thread-3结束！！！</span><br><span class="line">5050</span><br><span class="line">pool-1-thread-1开始！！！</span><br><span class="line">pool-1-thread-1结束！！！</span><br><span class="line">5050</span><br><span class="line">pool-1-thread-2开始！！！</span><br><span class="line">pool-1-thread-2结束！！！</span><br><span class="line">5050</span><br><span class="line">pool-1-thread-2开始！！！</span><br><span class="line">pool-1-thread-2结束！！！</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>这是get同步的结果。</p><h5 id="四种线程池的弊端"><a href="#四种线程池的弊端" class="headerlink" title="四种线程池的弊端"></a>四种线程池的弊端</h5><ul><li><p>对于 FixedThreadPool 和 SingleThreadPool，因为请求队列的长度为<code>Integer.MAX_VALUE</code>，可能会在队列中堆积大量的任务，导致OOM。</p></li><li><p>对于CchedThreadPool 和 ScheduledThreadPool，因为最大线程池大小<code>Integer.MAX_VALUE</code>，可能会创建大量的线程，导致OOM。</p></li></ul><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>阿里巴巴文档有说明：</p><blockquote><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><p>构造方法：</p><p><code>public ThreadPoolExecutor(intcorePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt;workQueue, RejectedExecutionHandler handler)</code></p><p>参数说明：</p><ul><li><strong>corePoolSize</strong>：运行任务的核心线程数，如果当前线程数等于核心线程数，则多余的任务会放到等待队列。</li><li><strong>maximumPoolSize</strong>：最大线程数。这里有一个机制，当等待队列中任务满，且当前任务数&lt;最大线程数，则会新开一个线程。</li><li><strong>keepAliveTime</strong>：线程所允许的空闲时间</li><li><strong>unit</strong>：线程池维护线程所允许的空闲时间的单位（NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS等）</li><li><strong>workQueue</strong>：等待队列</li><li><strong>handler</strong>：对拒绝任务的处理策略。当缓存队列满，且当前线程数达到了最大线程数(maxmumPoolSize)，则会采取拒绝策略。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当并发请求数量大而线程执行时间短的时候，使用常规的线程，就会出现频繁地创建和销毁。这样效率是极低的，服务器啥也不干就光在这创建销毁了，更别说还可能出现资源竞争。&lt;/p&gt;
&lt;p&gt;于是java中就引进了线程池，顾名思义，就是创建一个属于线程的池子，来统一管理调配线程。线程池可以避免大量的线程强占资源，避免大量线程的创建和销毁带来的开销。&lt;/p&gt;
&lt;p&gt;Executors类中提供了四种线程池，有对应的静态工厂来生成，然后实现ExecutorService接口来执行任务。&lt;/p&gt;
&lt;p&gt;四种常用的线程池：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="线程" scheme="https://heronking.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议简单总结</title>
    <link href="https://heronking.gitee.io/archives/ce0e21de.html"/>
    <id>https://heronking.gitee.io/archives/ce0e21de.html</id>
    <published>2020-04-04T10:04:37.000Z</published>
    <updated>2020-04-04T12:24:49.756Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP，超文本传输协议，是一个客户端和服务端<strong>请求和响应</strong>的<strong>标准TCP</strong>，建立在TCP之上。简单来说，就是用电脑上网，访问web，然后web服务器对电脑的请求作出响应。</p><p>互联网上所有的WWW文件都必须遵守HTTP标准。</p><p><code>http</code>协议在应用层，它是基于传输层的<code>TCP</code>协议。所以http在开始传输前，会首先建立tcp连接，也就是三次握手。</p><a id="more"></a><p><strong>为什么使用TCP协议而不是UDP协议？</strong></p><p>因为一个网页里面有很多数据需要传输，必须保证数据的完整性，不然网页就会出错。</p><h5 id="HTTP的工作流程"><a href="#HTTP的工作流程" class="headerlink" title="HTTP的工作流程"></a>HTTP的工作流程</h5><p>一次HTTP操控叫一个事务</p><blockquote><ul><li>客户端和服务器建立连接（三次握手）</li><li>建立连接后，发送HTTP请求</li><li>服务器收到请求，返回HTTP响应信息</li><li>如果模式为短连接，则服务器释放TCP连接（四次挥手）</li><li>客户端收到回复信息，通过浏览器解析HTML内容，把信息展示给用户。</li></ul></blockquote><h5 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h5><p>在<strong>HTTP/1.0</strong>中默认是短连接。每进行一个事务，就建立一次连接，事务结束就释放连接。web页中如果有其他的资源（比如JavaScript文件、图片、css这种），每遇到一个资源，就会重新建立一个HTTP会话。</p><p><strong>HTTP/1.1</strong>中默认是长连接，可以保持连接。使用长连接以后，当一个web页打开完成，客户端和服务器之间的TCP连接不会释放，当客户端再次访问这个服务器的时候，会继续使用这个没有释放的连接。</p><p>在响应头中加入 <code>Connection:keep-alive</code> 就会将HTTP转为长连接。</p><p>长连接让多个HTTP请求可以复用同一个TCP连接，这样可以节省很多连接和断开的消耗。当然，长连接不是永久连接。在header中可以设置一个超时时间，如果该连接在超时时间内没有HTTP请求，那么长连接会被释放。</p><h5 id="HTTP协议响应报文的状态码"><a href="#HTTP协议响应报文的状态码" class="headerlink" title="HTTP协议响应报文的状态码"></a>HTTP协议响应报文的状态码</h5><ul><li>1**，指示信息，表示请求已接收，需要请求继续执行操作</li><li>2**，成功，表示请求已被成功接收并处理</li><li>3**，重定向，让客户端实现URL重定向</li><li>4**，客户端错误，请求包含语法错误或无法完成请求</li><li>5**，服务器错误，服务器在处理请求的过程在发生错误</li></ul><h4 id="在浏览器中输入url地址到返回结果的过程"><a href="#在浏览器中输入url地址到返回结果的过程" class="headerlink" title="在浏览器中输入url地址到返回结果的过程"></a>在浏览器中输入url地址到返回结果的过程</h4><ul><li><strong>DNS解析</strong>，浏览器查找域名所对应的IP地址</li><li><strong>TCP连接</strong>，三次握手</li><li><strong>发送HTTP请求</strong>，客户端发送请求报文</li><li><strong>服务器处理请求并返回HTTP响应报文</strong>，服务器发回响应报文</li><li><strong>浏览器解析渲染页面</strong>，客户端处理数据</li><li><strong>连接释放</strong>，四次挥手</li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul><li><p>HTTP的URL是 <code>http://</code>开头，默认使用80端口；HTTPS的URL由<code>https://</code>开头，默认使用443端口。</p></li><li><p>HTTP协议是基于TCP的，传输内容是明文信息，客户端和服务器的无法验证发送方的身份。</p><p>HTTPS协议是基于SSL/TLS上的HTTP协议，而SSL/TLS是基于TCP的。该协议的所有内容都经过了加密。HTTP的安全性没有HTTPS高，但HTTPS要花费更多的服务器资源，因为需要对报文进行认证。</p></li></ul><h4 id="HTTP中的请求"><a href="#HTTP中的请求" class="headerlink" title="HTTP中的请求"></a>HTTP中的请求</h4><p>具体还是看图！http/1.1后有8个，还在增加中。<a href="https://blog.csdn.net/weixin_42981419/article/details/86162244?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">图源</a></p><p><img src="/archives/ce0e21de/1.png" alt="http请求方法"></p><h5 id="POST和PUT方法的区别"><a href="#POST和PUT方法的区别" class="headerlink" title="POST和PUT方法的区别"></a>POST和PUT方法的区别</h5><p>两者都能向指定资源进行创建或更新。</p><p>但<strong>PUT 是幂等的方法</strong>，如果对某个资源重复执行多次PUT，得到的结果仍然是一样的。对于两个相同的请求，后一个请求会将前一个请求覆盖。使用PUT方法可以指定路径明确操作的对象，如果服务器已经存在对象，则更新，不存在，则创建。</p><p>而<strong>POST方法不是幂等的</strong>，若重复执行多次POST方法，则会创建多个对象，因为后一个请求不会覆盖前面相同的请求。POST方法无法指定资源路径，服务器会为POST提交的新文档创建一个编号。</p><h5 id="GET和POST方法的区别"><a href="#GET和POST方法的区别" class="headerlink" title="GET和POST方法的区别"></a>GET和POST方法的区别</h5><p>GET方法提交的数据会直接放到请求报文的URL上，比如要在谷歌上搜索”计算机网络“，那么URL栏上是：”<a href="https://www.google.com/search?q=计算机网络&amp;ie=utf-8“，数据都在这上面了，而且URL是长度限制的。" target="_blank" rel="noopener">https://www.google.com/search?q=计算机网络&amp;ie=utf-8“，数据都在这上面了，而且URL是长度限制的。</a></p><p>POST方法提交的数据会在请求正文（body）中，没有长度限制。</p><p>所以GET方法一把用来传输可公开的参数，解析快。POST方法用来提交不公开的敏感信息，比GET要安全。</p><p>当然，如果不使用https加密，报文的body也是可被截取的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP，超文本传输协议，是一个客户端和服务端&lt;strong&gt;请求和响应&lt;/strong&gt;的&lt;strong&gt;标准TCP&lt;/strong&gt;，建立在TCP之上。简单来说，就是用电脑上网，访问web，然后web服务器对电脑的请求作出响应。&lt;/p&gt;
&lt;p&gt;互联网上所有的WWW文件都必须遵守HTTP标准。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http&lt;/code&gt;协议在应用层，它是基于传输层的&lt;code&gt;TCP&lt;/code&gt;协议。所以http在开始传输前，会首先建立tcp连接，也就是三次握手。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="计算机网络" scheme="https://heronking.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://heronking.gitee.io/archives/ff8068c0.html"/>
    <id>https://heronking.gitee.io/archives/ff8068c0.html</id>
    <published>2020-04-02T11:08:19.000Z</published>
    <updated>2020-04-06T13:05:42.565Z</updated>
    
    <content type="html"><![CDATA[<p>平时用多了 <code>std::sort()</code> 还有 <code>Arrays.sort()</code> ，一些基本的排序都忘了。</p><p>需要手撸一个快排锻炼一下自己。</p><p>快速排序是对冒泡排序的一种改进，最坏时间复杂度<strong>O(n²)</strong>（有序表），最优时间复杂度 <strong>O(nlgn)</strong> ，平均时间复杂度 <strong>O(nlgn)</strong>。</p><p><strong>快速排序是一种不稳定的排序方式</strong></p><p>什么叫不稳定？</p><a id="more"></a><p>比如一个数组（5，7a，4，7b，2，9），假设选取5作为基准值，那么根据快速排序，找到第一个比5大的数7a，再找第一个比5小的数2，把他们交换，这样数组就变成了（5，2，4，7b，7a，9）</p><p>这样，本来7a是在7b前面的，而其实却到了它后面，而且后续也不会再恢复了，这就打乱了稳定性。</p><p>同样的道理，<strong>直接选择排序、堆排序、希尔排序</strong>也不是稳定的排序。</p><p>手撕开始，先将数组根据基本值分为两部分，左边比基准小，右边比基准小</p><h5 id="左右指针法"><a href="#左右指针法" class="headerlink" title="左右指针法"></a>左右指针法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = end;<span class="comment">//选一个基准值</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[start] &lt;= a[key] &amp;&amp; start &lt; end) &#123;<span class="comment">//找左边第一个比基准值大的</span></span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (a[start] &gt;= a[key] &amp;&amp; start &lt; end) &#123;<span class="comment">//找右边第一个比基准值小的</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a[start], a[end]);<span class="comment">//把这两个数交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    swap(a[start], a[key]);<span class="comment">//此时start和end相等，把基准值拿过来，处于中间</span></span><br><span class="line">        <span class="keyword">return</span> start;<span class="comment">//返回的是基准值的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>举个栗子</strong>说明一下：</p><p>5 7 4 6 2 1 3    第一趟开始，基准值为5<br>5 3 4 6 2 1 7    交换7 3<br>5 3 4 1 2 6 7    交换6 1<br>5 3 4 1 2 6 7    此时start == end 退出循环（start在2的位置碰到了end）<br>2 3 4 1 5 6 7    交换start和基准值，让基准值放到中间</p><p>最后返回基准值的下标</p><p>然后，快排的主体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = sort2(a, start, end);</span><br><span class="line">        quickSort(a, start, mid - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取基准值，把数组拆分成两半，递归地继续排序，基准值的位置是正确的，所以不用管它了。</p><p>比如上面就是再拆分成 2 3 4 1和 6 7继续排序！最后就会获得一个香喷喷的排好序的数组！</p><p>后面还有挖坑法、前后指针法等等，还有优化方法啥的。</p><h5 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h5><p>大同小异吧，就是换一个思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把基准值拿出来，此时坑为right</span></span><br><span class="line">    <span class="keyword">int</span> key = a[right];</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="comment">//如果right为坑，那就要先找left</span></span><br><span class="line">        <span class="comment">//找到第一个比基准值大的</span></span><br><span class="line">        <span class="keyword">while</span> (a[left] &lt;= key &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把这个值挖出来填到right坑内，此时的坑为left</span></span><br><span class="line">        a[right] = a[left];</span><br><span class="line">        <span class="comment">//找第一个比基准值小的</span></span><br><span class="line">        <span class="keyword">while</span> (a[right] &gt;= key &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填到left坑内，此时的坑为right</span></span><br><span class="line">        a[left] = a[right];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后把基准值填到坑内。</span></span><br><span class="line">    a[left] = key;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样<strong>举个栗子</strong>：</p><p>5 7 3 6 2 1 4    原数组<br>5 7 3 6 2 1 []    right位置为第一个坑，取key = 4<br>[] 7 3 6 2 1 5    从左边找到第一个比key大的，挖出来填到坑里<br>1 7 3 6 2 [] 5    从右边找到第一个比key小的，填坑<br>1 [] 3 6 2 7 5    左边找大的<br>1 2 3 6 [] 7 5    右边找小的<br>1 2 3 [] 6 7 5    左边找大的，此时left指针在坑那里，right指针在6那里<br>                          right走一步，遇到了left，退出循环<br>1 2 3 4 6 7 5    把key放到坑里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时用多了 &lt;code&gt;std::sort()&lt;/code&gt; 还有 &lt;code&gt;Arrays.sort()&lt;/code&gt; ，一些基本的排序都忘了。&lt;/p&gt;
&lt;p&gt;需要手撸一个快排锻炼一下自己。&lt;/p&gt;
&lt;p&gt;快速排序是对冒泡排序的一种改进，最坏时间复杂度&lt;strong&gt;O(n²)&lt;/strong&gt;（有序表），最优时间复杂度 &lt;strong&gt;O(nlgn)&lt;/strong&gt; ，平均时间复杂度 &lt;strong&gt;O(nlgn)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速排序是一种不稳定的排序方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么叫不稳定？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="https://heronking.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>总结final关键字</title>
    <link href="https://heronking.gitee.io/archives/ef816ce.html"/>
    <id>https://heronking.gitee.io/archives/ef816ce.html</id>
    <published>2020-03-26T11:20:00.000Z</published>
    <updated>2020-03-26T13:31:27.566Z</updated>
    
    <content type="html"><![CDATA[<p>final是Java中的一个关键字，用来修饰变量、方法或者类，和static用法差不多。final可以理解成“无法改变”的意思。</p><p>但是，<strong>final不能用来修饰抽象类</strong>，这是因为final有这些特性：</p><a id="more"></a><ul><li>被final修饰的类<strong>不能被继承</strong>，在final类中的方法默认为final。所以它不能用来修饰抽象类，因为抽象类设计出来就是为了被继承，<a href="https://heronking.github.io/archives/e6551811.html" target="_blank" rel="noopener">前面</a> 已经提到过。</li><li>被final修饰的方法不能被子类重写，但是可以被继承过去。<br><strong>注意一下，private方法也是不能被子类重写的，所以private类型的方法默认是final的。</strong></li><li>对于一个final变量，如果是基本数据类型，那么它的数值在初始化之后就不能更改；<br>如果修饰的是一个引用，那么在初始化之后不能再指向其他的对象。<strong>如果引用内部的数据不是final，那么是可以进行修改的，只是引用的指向不能修改</strong><br>其实final变量也就是<strong>常量</strong>。</li><li>final不能用于修饰构造方法。</li></ul><h4 id="那么为什么要使用final呢？"><a href="#那么为什么要使用final呢？" class="headerlink" title="那么为什么要使用final呢？"></a>那么为什么要使用final呢？</h4><ol><li>锁定方法，防止子类重写。</li><li><strong>高效</strong>，final方法是内嵌调用机制。（但现在已经不需要了，因为private类型的方法默认都是final）</li></ol><h4 id="final和static的区别"><a href="#final和static的区别" class="headerlink" title="final和static的区别"></a>final和static的区别</h4><ul><li>final把数据修饰为常量，无法修改</li><li>static把数据修饰为静态，放入方法区</li></ul><h4 id="和finally、finalize-的区别"><a href="#和finally、finalize-的区别" class="headerlink" title="和finally、finalize()的区别"></a>和finally、finalize()的区别</h4><ul><li><strong>finally关键字</strong>，用于异常处理，无论是否抛出异常，finally代码块都会执行，可以用来维护对象的内部状态，清理资源。不要在try中使用return语句，因为会被finally覆盖。</li><li><strong>finalize方法</strong>，是Objecte类的方法。在GC决定回收一个没用的对象时调用。可以覆盖这个方法来选择回收资源还是执行清除操作，或者其他什么东西都行。任何对象只会被JVM调用一次finalize方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;final是Java中的一个关键字，用来修饰变量、方法或者类，和static用法差不多。final可以理解成“无法改变”的意思。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;final不能用来修饰抽象类&lt;/strong&gt;，这是因为final有这些特性：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="https://heronking.gitee.io/archives/3ecb78ee.html"/>
    <id>https://heronking.gitee.io/archives/3ecb78ee.html</id>
    <published>2020-03-25T06:00:03.000Z</published>
    <updated>2020-03-25T09:58:07.813Z</updated>
    
    <content type="html"><![CDATA[<p>在了解反射之前，要先知道什么是Class对象。</p><p>在java中对象分为两种：<strong>Class对象</strong>和<strong>实例对象</strong>。</p><p>实例对象是类的实例，用 <code>new</code> 来创建；</p><p>而Class对象，就是<strong>Class类的实例</strong>，嗯。。就是这么直接，在 <code>java.lang</code> 这个包下面，有一个类就叫Class。这个类内部可以记录其他类的成员、接口这些信息，也就是说，Class类是用来<strong>表示其他类的一个类</strong>。</p><a id="more"></a><p>java程序的执行需要经过<strong>编译、加载、链接、初始化</strong>这几个阶段。编译阶段JVM会将<code>.java</code>文件编译成 <code>.class</code> 文件，同时，在这个文件中生成Class对象。然后，JVM的加载机制会将Class对象加载到方法区中。</p><p>当我们需要实例化一个类的时候，JVM会在方法区中查看这个类的Class对象是否已经存在了，如果是，那么直接根据Class对象生成实例；如果没有，就先加载Class对象，再创建实例。</p><p><strong>在一个ClassLoader中只有一个Class对象</strong>（通常在一个JVM下只有一个ClassLoader），但可以根据这个Class对象创建多个对象实例。</p><h5 id="创建Class对象的方式"><a href="#创建Class对象的方式" class="headerlink" title="创建Class对象的方式"></a>创建Class对象的方式</h5><ul><li><code>类名.class</code> ，注意：<strong>这种方式在加载Class对象后不会初始化类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">"静态区域"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态代码块，如果初始化，静态代码块会执行</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = ClassTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果（在idea上）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk\bin\java.exe ...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line">什么都没输出</span><br></pre></td></tr></table></figure><ul><li><code>Class.forName()</code> 这种方法<strong>会初始化静态区域</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">"静态区域"</span>;</span><br><span class="line">    <span class="keyword">private</span> String m = <span class="string">"非静态"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态区域</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//非静态区域</span></span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.test.ClassTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk\bin\java.exe ...</span><br><span class="line">静态区域</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">只输出了静态区域的代码。</span><br></pre></td></tr></table></figure><p>可见，在加载Class对象到方法区，还将一起加载进来的静态方法初始化了。</p><ul><li><code>new class().getClass()</code> 这种方法是通过实例化对象调用的方式 get 到的Class对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">"静态区域"</span>;</span><br><span class="line">    <span class="keyword">private</span> String m = <span class="string">"非静态"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = ClassTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class.forName(<span class="string">"com.test.ClassTest"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"\n使用getClass："</span>);</span><br><span class="line">        <span class="keyword">new</span> ClassTest().getClass();</span><br><span class="line">        System.out.println(<span class="string">"实例化第二个："</span>);</span><br><span class="line">        <span class="keyword">new</span> ClassTest().getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk\bin\java.exe ...</span><br><span class="line">静态区域</span><br><span class="line"></span><br><span class="line">使用getClass：</span><br><span class="line">非静态</span><br><span class="line">实例化第二个：</span><br><span class="line">非静态</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>把三种方法放到一起比较，对于类的初始化，静态区域在加载到方法区之后，只会初始化一次。而非静态区域每次实例化都会执行一次。</p><h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><p>以往都是通过new来创建对象，反射机制会获取到该类的Class对象，然后通过Class对象获取到构造器对象，然后再通过构造器对象创建一个对象。</p><p>new创建就是“正”着创建对象，在程序运行之前就已经确定了要new的类是哪一个。</p><p>而反射就是“反”着来，它是在<strong>运行时</strong>才知道需要操作的类是哪一个，并获取类的完整构造，并调用对应的方法</p><h5 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">       <span class="comment">//先获取Class对象，类名是Reflect</span></span><br><span class="line">       String className = <span class="string">"com.test.Reflect"</span>;</span><br><span class="line">       Class aClass = Class.forName(className);</span><br><span class="line">       <span class="comment">//再获取构造器对象，在Reflect类中必须有构造器，不然找不到</span></span><br><span class="line">       Constructor constructor = aClass.getConstructor();</span><br><span class="line">       <span class="comment">//通过构造器实例化对象</span></span><br><span class="line">       Reflect reflect = (Reflect) aClass.newInstance();</span><br><span class="line">       reflect.id = <span class="number">1</span>;</span><br><span class="line">       reflect.setName(<span class="string">"第一个"</span>);</span><br><span class="line">       System.out.println(reflect.getName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>需要注意的是：要实例化的类中必须写构造方法，不然会抛出异常 NoSuchMethodException</p><h5 id="通过反射访问属性"><a href="#通过反射访问属性" class="headerlink" title="通过反射访问属性"></a>通过反射访问属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">       String className = <span class="string">"com.test.Reflect"</span>;</span><br><span class="line">       Class aClass = Class.forName(className);</span><br><span class="line">       Constructor constructor = aClass.getConstructor();</span><br><span class="line">       Reflect reflect = (Reflect) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取id字段</span></span><br><span class="line">       Field field = reflect.getClass().getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">       <span class="comment">//修改id的值</span></span><br><span class="line">       field.set(reflect, <span class="number">2</span>);</span><br><span class="line">       System.out.println(<span class="string">"id的值："</span> + reflect.id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先实例化以后（实例化的方法随意），可以通过Class对象获取到该对象的属性并访问修改。</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id的值：2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>注意 <code>getField() 和 getDeclareField()</code> 的区别</strong></p><ul><li><code>getField()</code> <strong>只能获取public的</strong>，包括<strong>继承过来的</strong>字段。</li><li><code>getDeclaredField()</code> 可以获取本类所有的字段，<strong>包括private</strong>的，但是<strong>不能获取继承</strong>来的字段。 (<strong>再注意</strong>： 这里<strong>只能获取到</strong>，但<strong>并不能访问</strong>该private字段的<strong>值</strong>,除非加上<strong>setAccessible(true)</strong>)</li></ul><h5 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, NoSuchFieldException, InvocationTargetException </span>&#123;</span><br><span class="line">       String className = <span class="string">"com.test.Reflect"</span>;</span><br><span class="line">       Class aClass = Class.forName(className);</span><br><span class="line">       Constructor constructor = aClass.getConstructor();</span><br><span class="line">       Reflect reflect = (Reflect) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过Class对象获取方法setName，第二参数是setName的参数类型</span></span><br><span class="line">       Method method = reflect.getClass().getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="comment">//对实例化对象调用获取到的方法</span></span><br><span class="line">       method.invoke(reflect, <span class="string">"反射调用方法"</span>);</span><br><span class="line">       System.out.println(<span class="string">"name的值："</span> + reflect.getName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name的值：反射调用方法</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h4 id="反射机制到底有什么用"><a href="#反射机制到底有什么用" class="headerlink" title="反射机制到底有什么用"></a>反射机制到底有什么用</h4><p>其实最主要的用途还是用来设计框架，达到解耦的目的，减少项目的维护成本。比如spring中的依赖注入，控制反转，就很好的用到了反射机制。</p><p>举个栗子：先准备两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买香蕉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<strong>new的方法</strong>话，如果我想买苹果，那就要 <code>new Apple().buyApple();</code> 但是，如果我不想买苹果了，我就要修改代码，先把买苹果删掉，然后写上 <code>new Banana().buyBanana();</code>，然后重新编译运行才能达到效果。</p><p>如果工程量很大呢？那业务层的代码要改很久，而且改了这个还可能对其他的业务造成影响。其实在Spring中提出的控制反转可以解决这个问题。</p><p><strong>这里使用反射机制</strong>，来实现一下</p><p>先创建一个txt文件放到src下面，内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class = com.test.Apple</span><br><span class="line">method = buyApple</span><br></pre></td></tr></table></figure><p>然后用反射机制开始操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//先读取文件到Properties</span></span><br><span class="line">        File fileOfSpring = <span class="keyword">new</span> File(<span class="string">"src/spring.txt"</span>);</span><br><span class="line">        Properties config = <span class="keyword">new</span> Properties();</span><br><span class="line">        config.load(<span class="keyword">new</span> FileInputStream(fileOfSpring));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制开展业务</span></span><br><span class="line">        <span class="comment">//先获取Class对象</span></span><br><span class="line">        Class aClass = Class.forName(config.getProperty(<span class="string">"class"</span>));</span><br><span class="line">        <span class="comment">//获取构造器</span></span><br><span class="line">        Constructor constructor =  aClass.getConstructor();</span><br><span class="line">        <span class="comment">//通过Class对象获取方法</span></span><br><span class="line">        Method method = aClass.getMethod(config.getProperty(<span class="string">"method"</span>));</span><br><span class="line">        <span class="comment">//实例一个Object对象</span></span><br><span class="line">        Object user = constructor.newInstance();</span><br><span class="line">        <span class="comment">//调用对象的方法，开展业务</span></span><br><span class="line">        method.invoke(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>不要忘记给类加上构造方法</strong></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">买苹果</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这个时候，如果我们想买香蕉怎么办？有反射机制，那就只需要更改spring.txt中配置就行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class = com.test.Banana</span><br><span class="line">method = buyBanana</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">买香蕉</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>如果提供一个接口来配置spring.txt中的文件，把接口开放给用户，那就实现了Spring框架中的控制反转。</p><p>反射就是它的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解反射之前，要先知道什么是Class对象。&lt;/p&gt;
&lt;p&gt;在java中对象分为两种：&lt;strong&gt;Class对象&lt;/strong&gt;和&lt;strong&gt;实例对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实例对象是类的实例，用 &lt;code&gt;new&lt;/code&gt; 来创建；&lt;/p&gt;
&lt;p&gt;而Class对象，就是&lt;strong&gt;Class类的实例&lt;/strong&gt;，嗯。。就是这么直接，在 &lt;code&gt;java.lang&lt;/code&gt; 这个包下面，有一个类就叫Class。这个类内部可以记录其他类的成员、接口这些信息，也就是说，Class类是用来&lt;strong&gt;表示其他类的一个类&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议简单总结</title>
    <link href="https://heronking.gitee.io/archives/55ac5dc4.html"/>
    <id>https://heronking.gitee.io/archives/55ac5dc4.html</id>
    <published>2020-03-23T07:11:17.000Z</published>
    <updated>2020-04-06T12:12:28.228Z</updated>
    
    <content type="html"><![CDATA[<p>TCP协议（Transmission Control Protocol），传输控制协议。属于<strong>传输层</strong>。</p><p>TCP负责检查传输的报文，一旦出现问题就发出信号，要求重新传输，直到所有的数据都安全正确地传输到目的地。</p><p>基于TCP的协议有 <code>HTTP、SMTP、FTP、Telnet、POP3</code>。</p><a id="more"></a><h5 id="TCP协议的应用场景、应用层协议"><a href="#TCP协议的应用场景、应用层协议" class="headerlink" title="TCP协议的应用场景、应用层协议"></a>TCP协议的应用场景、应用层协议</h5><p>要求通信数据可靠无误的时候，就像传输文件、邮件这一类的信息。</p><ul><li>万维网：<code>Http</code> 协议</li><li>邮件传输：<code>SMTP</code>协议</li><li>接受邮件：<code>POP3</code>协议</li><li>文件传输：<code>FTP</code>协议</li><li>远程登录：<code>Telnet</code>协议</li></ul><h5 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h5><p>面向连接、面向字节流、全双工通信、可靠的。（参考自 <a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">简书</a>）</p><p>具体如下：</p><table><thead><tr><th align="center">特点</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">面向连接</td><td align="center">使用TCP传输数据之前，必须先建立连接（三次握手）<br>传输完成后再释放连接（四次挥手）</td></tr><tr><td align="center">全双工通信</td><td align="center">建立TCP连接后，通信的双方都能发送数据</td></tr><tr><td align="center">可靠的</td><td align="center">通过TCP连接的数据不丢失、无差错、不重复、按顺序到达</td></tr><tr><td align="center">面向字节流</td><td align="center">数据以流的形式进行传输<br>流：流入流出进程的字符序列<br>TCP一次传输的报文长度是有限制的，如果超出限制就需要分块，然后依次传输。<br>接收方需要按照顺序接受分块的数据并把他们重新拼接成原样。</td></tr></tbody></table><p>TCP协议也因此<strong>效率较慢</strong>。</p><h5 id="TCP建立连接（三次握手）"><a href="#TCP建立连接（三次握手）" class="headerlink" title="TCP建立连接（三次握手）"></a>TCP建立连接（三次握手）</h5><p>先上图，<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">图源</a></p><img src="/archives/55ac5dc4/1.webp" alt="三次握手" style="zoom:80%;"><p><strong>字段含义</strong>：</p><ul><li>seq：sequence，序列号，就是报文段的序号，等于x就是第x个</li><li><strong>SYN</strong>：synchronize，同步标志，SYN=1、ACK=0表示请求连接；SYN=1、ACK=1表示请求响应</li><li><strong>ACK</strong>：acknowledge，确认标志，TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li><li>ack：确认号，等于x+1就代表正确收到了序号到x的数据</li><li><strong>FIN</strong>：finally，结束标志，等于1表示发送方数据发送完毕，要求释放连接</li></ul><p><strong>连接过程</strong>：</p><ul><li><p>连接前，客户和服务端都处于关闭状态、直到客户端主动打开连接，服务端才会被动打开，然后等待客户端请求。</p></li><li><p><strong>第一次握手</strong>，客户端向服务端发送连接请求（SYN=1）</p></li><li><p><strong>第二次握手</strong>，服务端收到请求，向客户端发送确认（SYN=1，ACK=1）。此时为服务器TCP连接分配资源</p></li><li><p><strong>第三次握手</strong>，客户端收到确认报文段，向服务器发送连接确认（ACK=1）。此时为客户端TCP连接分配资源</p></li><li><p>连接完成</p></li></ul><p>三次握手期间，任何一次未收到回复信息，都会重新发起握手。</p><h6 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h6><p>三次握手的最主要目的就是让双方确认自己和对方的发送与接收都是正常的。</p><p>假设只需要两次握手。</p><p>客户端发起请求连接，但是这个连接因为某种情况而阻塞，服务器并没有收到。客户端超时等待后没有收到服务端的回复，于是再次发起请求连接，这一次，服务器收到请求，发送确认，为客户端分配资源，连接完成。然后客户端和服务器愉快的进行信息交流，直到客户端发送了FIN=1，连接释放。</p><p>然后那个姗姗来迟的请求这时候到了，服务器以为是一个新的请求，于是也发回了一个确认，并为这个请求分配资源。但是客户端早就忘了这个超时的请求，而且此时并没有发送过请求，所以对于这个确认，客户端不会回应。</p><p>于是服务器就一直等待，<strong>形成死锁，造成资源浪费</strong></p><p>当大量的无回应请求出现时，服务器就受到了<strong>SYN洪泛攻击</strong>。</p><p>而连接变成三次握手时，在第三次握手完成前，即客户端发回确认之前，服务器不会为客户端TCP连接分配资源，连接没有完成就不用等待客户端的数据，也就不会死锁了。</p><p>当然，在三次握手中，在客户端收到的服务器响应SYN+ACK报文时，会判断这个报文是否为历史报文（序列号过期或者超时），此时，客户端就会发送一个<strong>RST报文</strong>给服务器，终止这个报文连接。</p><p>因此，<strong>三次握手可以阻止历史连接的初始化</strong>，<strong>避免资源浪费</strong>。</p><h5 id="释放连接（四次挥手）"><a href="#释放连接（四次挥手）" class="headerlink" title="释放连接（四次挥手）"></a>释放连接（四次挥手）</h5><p>上图，<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">图源</a></p><img src="/archives/55ac5dc4/2.webp" alt="四次挥手" style="zoom:80%;"><p><strong>连接过程</strong>：</p><ul><li><p>连接前，双方都是已创建状态，直到客户端主动关闭连接。</p></li><li><p><strong>第一次挥手</strong>，客户端向服务器发送连接释放（FIN=1），表示数据发送完毕。</p></li><li><p><strong>第二次挥手</strong>，服务端收到释放请求，向客户端发送释放确认（ACK=1）。<br>此时服务器进入关闭等待，但是可能还有数据要传给客户端。客户端收到确认后，等待服务器的数据传输完成。</p></li><li><p><strong>第三次挥手</strong>，服务器向客户端发送连接释放（FIN=1），表示数据发送完毕。</p></li><li><p><strong>第四次挥手</strong>，客户端收到释放请求，向服务器发送确认（ACK=1）。服务器收到确认后关闭，但客户端进入时间等待（TIME-WAIT），经过<strong>2MSL</strong>（<strong>两个最长报文段寿命</strong>）后依然没有回复，客户端关闭。</p></li><li><p>连接释放。</p></li></ul><h6 id="为什么要等四次挥手？"><a href="#为什么要等四次挥手？" class="headerlink" title="为什么要等四次挥手？"></a>为什么要等四次挥手？</h6><p>目的是，为了保证双方连接释放后，都无法再接受和发送消息。TCP是全双工通信，即使一方释放连接，另一方的连接没有释放，就能继续发送</p><p><strong>为什么要等2MSL？</strong></p><p>为了保证第四次挥手的确认报文能到达服务器，使服务器正常关闭。</p><p>如果客户端发完报文直接关闭，那么当确认报文阻塞或丢失后，服务器等待超时重发连接释放，客户端就收不到，服务器就无法关闭。</p><p>2MSL能保证因为阻塞失效的报文段消失，避免在下次连接中出现。</p><h5 id="TCP协议如何保证可靠传输？"><a href="#TCP协议如何保证可靠传输？" class="headerlink" title="TCP协议如何保证可靠传输？"></a>TCP协议如何保证可靠传输？</h5><ol><li><p>TCP对数据进行合理的<strong>分片和编号</strong>，接收方按照编号对这些数据包排序，组合成原本的数据后再提交给应用层。</p></li><li><p><strong>校验和</strong>，发送数据时，发送端会计算TCP报文段首部和数据的检验和，然后由接收端验证。如果接收端验证校验和有差错，TCP将丢弃该报文。</p></li><li><p>TCP接收端会<strong>丢弃重复的数据</strong>。</p></li><li><p><strong>流量控制</strong>，TCP使用<strong>滑动窗口</strong>实现流量控制。滑动窗口指的是发送方的发送窗口，窗口在报文段上滑动，只有当接收方确认收到数据后，发送窗口才向后滑动。窗口大小根据接受方处理数据的能力变化。</p></li><li><p><strong>拥塞控制</strong>，TCP使用<strong>慢开始、拥塞避免、快重传和快恢复</strong>来进行拥塞控制。</p><ul><li><p><strong>慢开始</strong>：由小（数值为1）到大逐渐增加<strong>拥塞窗口</strong>大小（cwnd，发送窗口），<strong>试探</strong>网络情况。每经过一个轮播（把cwnd中的所有报文都发送了，并收到了最后一个字节的确认），cwnd翻倍。</p></li><li><p><strong>拥塞避免</strong>：使cwnd<strong>按线性缓慢增长</strong>，经过一个轮播，cwnd+1。（<strong>并不能避免拥塞</strong>，只是让拥塞更不容易出现）</p></li><li><p><strong>快重传和快恢复（FFR）</strong>：当接收方发现一个顺序错的数据段，会立即给发送方发一个重复确认（比如先收到了1和2，但是下一个却是收到了4，接下来的5和6也是错的）。当连续收到3个重复确认，发送机就会重发丢失的数据段。不会使cwnd重置为1然后慢开始。</p></li></ul></li><li><p><strong>ARQ协议</strong>：自动重传请求。每发完一组数据就停止，等待对方确认。收到确认再发下一组。</p></li><li><p><strong>超时重传</strong>：TCP发出一段报文后，会启动定时器，如果不能及时收到确认，就会重传这个报文。</p></li></ol><h5 id="TCP协议和UDP协议的区别"><a href="#TCP协议和UDP协议的区别" class="headerlink" title="TCP协议和UDP协议的区别"></a>TCP协议和UDP协议的区别</h5><ul><li>UDP协议传输数据前不需要建立连接，接受方收到UDP报文后，不需要回复确认</li><li>UDP传输的数据不保证可靠性</li><li>UDP的传输效率更高、所需资源更少。</li><li>UDP的传输形式是数据报文段。TCP是字节流，把数据分成很多数据段。</li><li>UDP传输应用于对通信速度要求高的场景，比如即时通讯。</li><li>UDP数据报的首部只有8个字节，TCP有20个。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP协议（Transmission Control Protocol），传输控制协议。属于&lt;strong&gt;传输层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP负责检查传输的报文，一旦出现问题就发出信号，要求重新传输，直到所有的数据都安全正确地传输到目的地。&lt;/p&gt;
&lt;p&gt;基于TCP的协议有 &lt;code&gt;HTTP、SMTP、FTP、Telnet、POP3&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="https://heronking.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL慢查询及优化</title>
    <link href="https://heronking.gitee.io/archives/708bc100.html"/>
    <id>https://heronking.gitee.io/archives/708bc100.html</id>
    <published>2020-03-22T08:48:09.000Z</published>
    <updated>2020-03-22T09:26:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中将超过指定时间的sql语句查询成为<strong>慢查询</strong>，可以通过日志来查看记录下的慢查询语句，这个功能需要在配置文件中开启。</p><p>使用咒语：<code>set global slow_query_log = 1</code> ，开启慢查询日志，但只对当前数据库生效，如果MySQL重启则会失效。如果要永久生效，就必须修改配置文件。</p><p>具体怎么配置可以看 <a href="https://www.cnblogs.com/kerrycode/p/5593204.HTML" target="_blank" rel="noopener">这里</a></p><a id="more"></a><h4 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h4><p>先看一下关于创建索引的 <a href="https://heronking.github.io/archives/43a71ae4.html" target="_blank" rel="noopener">五大基本原则</a> ，建立一个好的索引是提高效率的重要前提。</p><p><strong>优化的基本步骤</strong>：</p><blockquote><p>0.<strong>先运行看看</strong>是否真的很慢，注意设置SQL_NO_CACHE</p><p>1.<strong>where条件单表查，锁定最小返回记录表</strong>。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p><p>2.<strong>explain查看执行计划</strong>，是否与1预期一致（从锁定记录较少的表开始查询）</p><p>3.<strong>order by limit</strong> 形式的sql语句让排序的表优先查</p><p>4.了解业务方<strong>使用场景</strong></p><p>5.<strong>加索引</strong>时参照建索引的几大原则</p><p>6.观察结果，不符合预期继续从0分析</p></blockquote><p>具体情况还没了解透彻~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL中将超过指定时间的sql语句查询成为&lt;strong&gt;慢查询&lt;/strong&gt;，可以通过日志来查看记录下的慢查询语句，这个功能需要在配置文件中开启。&lt;/p&gt;
&lt;p&gt;使用咒语：&lt;code&gt;set global slow_query_log = 1&lt;/code&gt; ，开启慢查询日志，但只对当前数据库生效，如果MySQL重启则会失效。如果要永久生效，就必须修改配置文件。&lt;/p&gt;
&lt;p&gt;具体怎么配置可以看 &lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/5593204.HTML&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MySQL" scheme="https://heronking.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://heronking.gitee.io/archives/43a71ae4.html"/>
    <id>https://heronking.gitee.io/archives/43a71ae4.html</id>
    <published>2020-03-21T12:28:07.000Z</published>
    <updated>2020-03-24T06:26:48.192Z</updated>
    
    <content type="html"><![CDATA[<p>数据库中存放着大量的数据，为了提高查找数据的效率，就需要索引。和字典里面的索引目录意义是一样的。</p><p>但数据库要复杂得多，因为往往需要的不仅仅是等值查询，还有范围查询、并集查询、模糊查询。当数据库中存储了非常多的数据，如果是散乱的数据，那么查询基本上都是全表扫描，这样已经谈不上效率不效率了。。</p><p>所以需要对这些数据设计索引，好的索引将大大提升查询效率。</p><a id="more"></a><h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><p>如果有千万级别的数据，可以想到构建一棵<strong>搜索树</strong>，查询效率是O(lgN)。但是数据库把数据放在磁盘上，计算机访问磁盘的成本是访问内存的十万倍左右。普通的机械硬盘，一次磁盘IO可能需要4毫秒以上。</p><p>而操作系统对此有相应的优化，每次磁盘IO都读取一页的数据，一页根据系统一般是4K或者8K（<strong>在MySQL的Innodb引擎中，一页是16K</strong>），读取当前磁盘数据的时，还把相邻数据的地址也读入缓冲区。</p><p>那么索引的数据结构目的就是，把每次查找数据时需要进行的磁盘IO次数尽量减少，最好是常数级。嗯，就是<strong>B+树</strong>。</p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>多路平衡搜索树，所有叶子都在同一层</p><p>上图</p><p><img src="/archives/43a71ae4/1.png" alt="B+树"></p><p>来源 <a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">图源</a>，这里面讲的非常清楚，包括插入和删除。这是一颗4阶B+树，高度是两层，叶子结点存着键值对，并且有指向相邻叶子节点的指针，某种意义上来讲，叶子串起来是一个顺序链表。非叶子节点只存储key，用来指引搜索的方向。</p><p>每一个节点都是一个磁盘块，上图一共5个。他们都存在磁盘中。</p><h6 id="查找方式"><a href="#查找方式" class="headerlink" title="查找方式"></a>查找方式</h6><p>如果这个时候要查找24这个的数据。</p><ul><li>首先加载根节点磁盘块，发生一次IO，通过二分法查到24比23大，55小</li><li>加载23 24 30这个磁盘块，再发生一次IO，二分法查找到24，搜索完成了。</li></ul><p>很明显，这棵树越高，那么磁盘IO的次数就越多。</p><p>一般来说，3层以上的B+树可以表示百万级的数据，磁盘IO只需要三次。大多数Innodb的B+树都是3层，可以存千万条数据</p><h6 id="为什么要把数据放到叶子中？"><a href="#为什么要把数据放到叶子中？" class="headerlink" title="为什么要把数据放到叶子中？"></a>为什么要把数据放到叶子中？</h6><p>为了让树的高度尽量小，那么就要让阶数尽量大，也就是让一个节点中key的个数尽量多</p><p>磁盘块的大小是固定，如果在非叶子节点中存储数据，显然键值对比单纯存key要大，磁盘块中能存放的key数量也因此减少了。树的高度也不可避免的增高。</p><h6 id="为什么B-树比B树更适合索引？"><a href="#为什么B-树比B树更适合索引？" class="headerlink" title="为什么B+树比B树更适合索引？"></a>为什么B+树比B树更适合索引？</h6><ul><li><p>B树的非叶子结点也存储了数据。那么在数据量大的时候，B树会比B+树更高，每多一次IO都消耗很大。</p></li><li><p>B+树的查询效率更加稳定，每次搜索数据都是从根节点走到叶子点。</p></li><li><p>在进行整库搜索时，B+树只需要搜索叶子，而B数需要中序遍历。所以B+树更适合<strong>范围查询</strong>。</p></li></ul><h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>在Innodb引擎中，<strong>聚集索引</strong>是，叶子节点存放着数据，也就是上面的B+树。<strong>一个表中只能有一个聚集索引</strong>，表中的数据会按照聚集索引的顺序存储。检索效率比非聚集索引高。</p><p><strong>非聚集索引</strong>，也是B+树，但是叶子节点还是索引，只不过里面存放着一个指向数据块的指针。也就是说在非聚集索引中，只有索引项按键值的顺序排列，而实际上和索引对应的表中的数据，是按聚集索引排列的。<strong>可以有很多个聚集索引</strong></p><p><strong>举个栗子</strong>：</p><p>新华字典，如果要查”王（wang）“这个字，我们知道他的拼音，就不用去翻目录，因为字典里面排列的顺序是按拼音来的，我们只用翻到”W“开头的那一页，再找W中的“ang”部分就可以发现“王”字。</p><p>所以拼音是新华字典的聚集索引，所有的数据都按照聚集索引排列好。</p><p>但是新华字典还有目录，比如笔画目录。现在要查一个字”王“，如果我们要按照笔画来查，就要先在笔画目录中找到4划的部分，然后里面有很多字，”王“、文“，”木“。在笔画目录中，所有的字都按笔画排好了，但是他们在实际的表中并不是这个顺序，比如王在400页，而文在450页，木在200页。</p><p>所以笔画目录是非聚集索引。</p><p><strong>一般来说</strong>，参考自 <a href="https://zhuanlan.zhihu.com/p/39293940" target="_blank" rel="noopener">知乎</a>：</p><blockquote><p>聚集索引默认是表中的主键索引，如果表中没有显示指定主键，则会选择表中的<strong>第一个不允许为NULL的唯一索引</strong>。如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。</p><p>每张表只有一个聚集索引，因为聚集索引在精确查找和范围查找方面良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增id充当聚集索引）。</p></blockquote><p>在MyISAM中的索引使用的是非聚集索引。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>咒语：</p><ul><li><code>create index xxxx on table(xxxx(length));    //length就是长度</code> </li><li><code>create unique index xxxx on table(xxxx(length));    //唯一索引</code></li><li><code>alter table xxxx add index xxxx(column);   //column就是列名</code></li><li>查看索引：<code>show index from xxx;</code></li></ul><p><strong>创建索引的几大基本原则</strong>：</p><blockquote><p>1.<strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2.<strong>=和in可以乱序</strong>，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><p>3.<strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p><p>4.<strong>索引列不能参与计算，保持列“干净”</strong><br>比如 <code>from_unixtime(create_time) = ’2014-05-29’</code> 就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。<br>所以语句应该写成 <code>create_time = unix_timestamp(’2014-05-29’)</code>。</p><p>5.<strong>尽量的扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库中存放着大量的数据，为了提高查找数据的效率，就需要索引。和字典里面的索引目录意义是一样的。&lt;/p&gt;
&lt;p&gt;但数据库要复杂得多，因为往往需要的不仅仅是等值查询，还有范围查询、并集查询、模糊查询。当数据库中存储了非常多的数据，如果是散乱的数据，那么查询基本上都是全表扫描，这样已经谈不上效率不效率了。。&lt;/p&gt;
&lt;p&gt;所以需要对这些数据设计索引，好的索引将大大提升查询效率。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="MySQL" scheme="https://heronking.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://heronking.gitee.io/archives/f91535f.html"/>
    <id>https://heronking.gitee.io/archives/f91535f.html</id>
    <published>2020-03-21T06:59:01.000Z</published>
    <updated>2020-03-21T09:24:23.849Z</updated>
    
    <content type="html"><![CDATA[<p>事务处理技术包括数据库回复技术和并发控制技术。这个两个机制是DBMS的重要组成部分。</p><h4 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h4><p>事务是用户定义的一个操作序列。这些操作<strong>要么都成功完成、要么都失败</strong>，他们是一个不可分割的工作单位。</p><a id="more"></a><h5 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h5><p>总结为ACID四个特征</p><ul><li>原子性（Atomicity）：事务已经是最小的单位了，不可分割，无论这个事务中有多少个步骤，他们是一个整体，要么全部成功，要求全部失败</li><li>一致性（consistency）：事务必须使数据库从一个正确的状态迁移到另一个争取的状态，也就是说，如果在执行事务之前，库中的数据是合理满足约束的，那么执行事务之后，也应该如此。</li><li>隔离性（isolation）：一个事务的执行不会被其他事务所干扰</li><li>持久性（durability）：每一次事务提交后就保证不会丢失。提交之后对数据库中的数据改变是永久的。</li></ul><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p>银行转账：a 给 b 转账1000，这里就涉及到两条操作</p><p>1.先把a的钱减去1000</p><p>​    <code>update user set money = money - 1000 where name = &#39;a&#39;;</code></p><p>2.再把b的钱加上1000</p><p>​    <code>update user set money = money + 1000 where name = &#39;b&#39;;</code></p><p>如果这两条指令只有a成功，b失败，那a就亏了钱。b成功，a失败，那就是白给1000.</p><p>所以他们是一个事务，要么一起成功，要么一起失败。</p><h4 id="如何控制事务"><a href="#如何控制事务" class="headerlink" title="如何控制事务"></a>如何控制事务</h4><p>MySQL中是默认设置下，事务是自动提交（@autocommit）。</p><p>作用是，当我们执行了一个sql语句，按下回车就能出现结果，这就是自动提交，而且不能回滚了。</p><p><strong>什么是回滚？</strong><br>即 rollback 命令，执行之后<strong>撤销未提交</strong>的sql命令。</p><p><strong>通过手动开启自己的事务</strong>。</p><p>可以先关闭自动提交：<code>set autocommit = 0;</code> </p><p>执行sql语句以后，我们对表和数据的修改效果会出现在临时的表中，对于不满意的修改可以使用 <code>rollback</code> 回滚操作。修改完成后，使用咒语 <code>commit</code> 提交修改，<strong>提交之后不可撤销</strong>。</p><p>或者使用咒语 <code>begin;</code> 或 <code>start transaction;</code>，即使自动提交没有关闭也能开启一个不会自动提交的事务。</p><p>在事务中的操作可以通过 <code>rollback</code> 回滚。修改完成需要 <code>commit</code> 提交，<strong>提交之后事务结束</strong>。</p><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li><p><strong>read uncommitted</strong>：读未提交，可能会出现<strong>脏读</strong>问题</p><p><strong>栗子</strong>：老板发工资了（开启事务1，并update），张三去查了自己的余额发现是5000（事务2，select），张三很开心（commit事务2）。<br>但张三的实际工资应该是2000，于是老板回滚操作，并发2000（rollback，然后update），最后核实无误再提交（commit事务1）.</p><p>并发的事务中，一个事务可能查询另外的事务的未提交数据。这就是<strong>脏读</strong></p></li><li><p><strong>read committed</strong>：读已提交，可能会出现<strong>不可重复读</strong>问题</p><p><strong>栗子</strong>：张三准备用刚发的2000块工资去吃一块新疆切糕，查一下钱是2000（事务1，select），然后准备把钱拿出来。<br>这时候张三的女朋友用他的工资卡买了一个2000块的包包（事务2，update），并在张三之前提交了该事务（commit事务2）。<br>这个时候取钱却发现余额不足，于是张三选择再看一遍工资卡（select），此时余额变成了0，张三不停地 select，但每一次余额都是0，于是他只能悲哀地commit。</p><p>并发的事务访问同一个数据，事务1先查询，事务2马上更新数据并提交，事务1再次查询读取数据时，该数据已经改变。</p><p>这个级别虽然可以<strong>避免脏读</strong>，但是可能会出现<strong>不可重复读</strong>的问题。</p></li><li><p><strong>repeatable read</strong>：重复读，可能会出现<strong>幻读</strong>问题</p><p>该隔离级别可以避免不可重复读。当事务1开始查询数据，在事务1提交之间，事务1无论何时查询到的数据都是一样的。这个和上面差不多，会出现新的问题。</p><p><strong>栗子</strong>：张三换了级别准备再去取钱，先查一下（事务1开始，select）。这个时候张三的老婆以迅雷不及掩耳盗铃之势转走工资卡里的钱并马上提交（事务2，update，commit）。<br>于是张三取钱再次失败了，余额不足，他再查了一遍（select），余额明明和刚开始时一样的，并且不管select多少次，余额都不变，但是钱却取不出来。张三感觉，这应该是梦。</p><p>这就是<strong>幻读</strong>。</p><p><strong>需要注意的是</strong>，MySQL的innoDB引擎默认是RR级别，并且已经通过MVCC自动解决了幻读问题，所以已经模拟不出来了。幻读和不可重复读十分类似，都是因为非线程安全。</p></li><li><p><strong>serializable</strong>：序列化</p><p>这是最高的级别，可以避免所有的问题。因为这个级别下，数据是线程安全的。</p><p>所谓序列化，就是给数据加同步锁。这个锁是针对<strong>写操作</strong>的。</p><p><strong>栗子</strong>：这次张三换了最高级别去取钱，同样先查一下（事务1，select）。张三的老婆发动故技重施，先转走所有的钱（事务2，update），但是却发现，银行柜台机卡住了，转账中这个界面一直在转。<br>然后张三取出钱，最后提交了（事务1，commit）。假设<strong>没有超时</strong>，这时，张三老婆那边就显示，转账失败，余额不足。如果超时了，那边就显示，超时请重试。</p><p>当一个事务1访问数据时，其他并发事务对该数据的<strong>写操作</strong>会进入等待阻塞（序列化），在事务1后面排队。直到事务1提交，下一个事务如果没有超时，才能对数据进行操作。</p><p>这个级别性能十分低，花费资源多，一般很少使用。</p></li></ul><h5 id="查看和修改系统的隔离级别"><a href="#查看和修改系统的隔离级别" class="headerlink" title="查看和修改系统的隔离级别"></a>查看和修改系统的隔离级别</h5><p>MySQL 8.0以上查询，使用咒语：</p><p><code>select @@global.transaction_isolation;  //系统级别</code><br><code>select @@transaction_isolation;  //会话级别</code></p><p>一般两个都是  <strong>REPEATABLE-READ</strong></p><p>修改：</p><p><code>set global transaction isolation level xxxxx;     //修改系统级别</code><br><code>set transaction isolation level xxxxx;     //修改会话级别</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务处理技术包括数据库回复技术和并发控制技术。这个两个机制是DBMS的重要组成部分。&lt;/p&gt;
&lt;h4 id=&quot;事务的基本概念&quot;&gt;&lt;a href=&quot;#事务的基本概念&quot; class=&quot;headerlink&quot; title=&quot;事务的基本概念&quot;&gt;&lt;/a&gt;事务的基本概念&lt;/h4&gt;&lt;p&gt;事务是用户定义的一个操作序列。这些操作&lt;strong&gt;要么都成功完成、要么都失败&lt;/strong&gt;，他们是一个不可分割的工作单位。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MySQL" scheme="https://heronking.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询记录</title>
    <link href="https://heronking.gitee.io/archives/50092300.html"/>
    <id>https://heronking.gitee.io/archives/50092300.html</id>
    <published>2020-03-20T09:23:54.000Z</published>
    <updated>2020-03-20T14:45:28.975Z</updated>
    
    <content type="html"><![CDATA[<p>一些查询语句，防止忘记。</p><a id="more"></a><h5 id="查最高成绩"><a href="#查最高成绩" class="headerlink" title="查最高成绩"></a>查最高成绩</h5><p>运用子查询，但是如果有多个最高成绩只能差一个</p><p><code>select sno, cno from score where degree = (select max(degree) from score);</code></p><p>或者</p><p><code>select sno,cno,degree from score order by degree desc limit 0,1;</code></p><p>先逆序然后选取</p><p>limit的参数0表示从第0个开始，1表示选取一个。有几个最高就选几个。</p><p>结果都是</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 103 | 3-105 |     92 |<br>+—–+——-+——–+</p><h5 id="查平均成绩"><a href="#查平均成绩" class="headerlink" title="查平均成绩"></a>查平均成绩</h5><p>这是查一门课：</p><p><code>select avg(degree) from score where cno = &#39;3-105&#39;;</code></p><p>结果</p><p>+————-+<br>| avg(degree) |<br>+————-+<br>|     85.3333 |<br>+————-+</p><p>查每一门课程：</p><p><code>select cno,avg(degree) from score group by cno;</code></p><p>先分组再算</p><p>结果</p><p>+——-+————-+<br>| cno   | avg(degree) |<br>+——-+————-+<br>| 3-105 |     85.3333 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+——-+————-+</p><h5 id="查询成绩表中至少有2名学生选修以3开头的课程的平均分数。"><a href="#查询成绩表中至少有2名学生选修以3开头的课程的平均分数。" class="headerlink" title="查询成绩表中至少有2名学生选修以3开头的课程的平均分数。"></a>查询成绩表中至少有2名学生选修以3开头的课程的平均分数。</h5><p><code>select cno,avg(degree),count(*) from score group by cno having count(cno) &gt;= 2 and cno like(&#39;3-%&#39;);</code></p><p>‘%’就相当于正则里面的‘*’，having和where类似，但having只能跟在group by后面，where只能跟在from后面。</p><p>结果</p><p>+——-+————-+———-+<br>| cno   | avg(degree) | count(*) |<br>+——-+————-+———-+<br>| 3-105 |     85.3333 |        3 |<br>| 3-245 |     76.3333 |        3 |<br>+——-+————-+———-+</p><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,cno,degree </span><br><span class="line"><span class="keyword">from</span> student,score </span><br><span class="line"><span class="keyword">where</span> student.sno = score.sno <span class="keyword">order</span> <span class="keyword">by</span> cno;</span><br></pre></td></tr></table></figure><p>根据两个表中的相同数据连接</p><p>结果</p><p>+———–+——-+——–+<br>| sname     | cno   | degree |<br>+———–+——-+——–+<br>| 王丽      | 3-105 |     92 |<br>| kuangming | 3-105 |     88 |<br>| lijun     | 3-105 |     76 |<br>| 王丽      | 3-245 |     86 |<br>| kuangming | 3-245 |     75 |<br>| lijun     | 3-245 |     68 |<br>| 王丽      | 6-166 |     85 |<br>| kuangming | 6-166 |     79 |<br>| lijun     | 6-166 |     81 |<br>+———–+——-+——–+</p><h5 id="查询和某人同年出生"><a href="#查询和某人同年出生" class="headerlink" title="查询和某人同年出生"></a>查询和某人同年出生</h5><p>假设某人是学号为108和101的两个人</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(sbirth) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">year</span>(sbirth) </span><br><span class="line">    <span class="keyword">from</span> student </span><br><span class="line">    <span class="keyword">where</span> sno <span class="keyword">in</span> (<span class="number">108</span>, <span class="number">101</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过子查询先选取年份</p><p>结果</p><p>+—–+———–+——+————+——-+<br>| sno | sname     | ssex | sbirth     | class |<br>+—–+———–+——+————+——-+<br>| 101 | 曾华      | 男   | 1977-09-01 | 95033 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     |<br>| 108 | znehua    | man  | 1997-09-01 | 1     |<br>+—–+———–+——+————+——-+</p><h5 id="多表嵌套子查询"><a href="#多表嵌套子查询" class="headerlink" title="多表嵌套子查询"></a>多表嵌套子查询</h5><p>选某个课程选修人数大于2人的教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> tno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> tno <span class="keyword">from</span> course</span><br><span class="line">    <span class="keyword">where</span> cno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> cno <span class="keyword">from</span> score</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> cno</span><br><span class="line">        <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>先找到选同一门课人数大于2的课程号</li><li>再从这些找到这些课程号的教师编号</li><li>通过教师编号查询教师信息</li></ul><p>结果</p><p>+—–+——–+——+————+———–+—————–+<br>| tno | tname  | tsex | birth      | prof      | depart          |<br>+—–+——–+——+————+———–+—————–+<br>| 804 | 李诚   | 男   | 1958-12-02 | 副教授    | 计算机系        |<br>| 825 | 王萍   | 女   | 1972-05-05 | 助教      | 计算机系        |<br>| 856 | 张旭   | 男   | 1969-03-12 | 讲师      | 电子工程系      |<br>+—–+——–+——+————+———–+—————–+</p><h5 id="union和not-in的使用"><a href="#union和not-in的使用" class="headerlink" title="union和not in的使用"></a>union和not in的使用</h5><p>查询两个系内职称不同的教师信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher </span><br><span class="line"><span class="keyword">where</span> depart = <span class="string">'电子工程系'</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">prof <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> prof <span class="keyword">from</span> teacher</span><br><span class="line">    <span class="keyword">where</span> depart = <span class="string">'计算机系'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher </span><br><span class="line"><span class="keyword">where</span> depart = <span class="string">'计算机系'</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">prof <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> prof <span class="keyword">from</span> teacher</span><br><span class="line">    <span class="keyword">where</span> depart = <span class="string">'电子工程系'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先分别把对方系内没有的职称找出来，然后把两个系用 union 连接</p><p>结果</p><p>+—–+——–+——+————+———–+—————–+<br>| tno | tname  | tsex | birth      | prof      | depart          |<br>+—–+——–+——+————+———–+—————–+<br>| 856 | 张旭   | 男   | 1969-03-12 | 讲师      | 电子工程系      |<br>| 804 | 李诚   | 男   | 1958-12-02 | 副教授    | 计算机系        |<br>+—–+——–+——+————+———–+—————–+</p><p>如果用分组聚合来找不同，需要注意的是，<strong>对group by进行查询只能查group by指定的聚合列、聚合函数、常量</strong>。不过，可以通过更改sql模式来查询。现在不能查询非聚合列的模式是<strong>ONLY_FULL_GROUP_BY</strong>。</p><h5 id="子查询any"><a href="#子查询any" class="headerlink" title="子查询any"></a>子查询any</h5><p>查询3-105课程的成绩中大于3-245课程成绩中的至少一个的成绩。（鬼才语文）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">where</span> cno = <span class="string">'3-105'</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">degree &gt; <span class="keyword">any</span> (</span><br><span class="line"><span class="keyword">select</span> degree <span class="keyword">from</span> score</span><br><span class="line">    <span class="keyword">where</span> cno = <span class="string">'3-245'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> degree <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>any的意思是其中任意一个。如果要查询比其中<strong>所有</strong>都要大的，那只需要<strong>把any改成all</strong>。</p><p>结果</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 103 | 3-105 |     92 |<br>| 105 | 3-105 |     88 |<br>| 109 | 3-105 |     76 |<br>+—–+——-+——–+</p><h5 id="查询成绩小于该课程平均成绩的分数信息"><a href="#查询成绩小于该课程平均成绩的分数信息" class="headerlink" title="查询成绩小于该课程平均成绩的分数信息"></a>查询成绩小于该课程平均成绩的分数信息</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score a</span><br><span class="line">  <span class="keyword">where</span> degree &lt; (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">avg</span>(degree) <span class="keyword">from</span> score b</span><br><span class="line">    <span class="keyword">where</span> a.cno = b.cno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结果</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 105 | 3-245 |     75 |<br>| 105 | 6-166 |     79 |<br>| 109 | 3-105 |     76 |<br>| 109 | 3-245 |     68 |<br>| 109 | 6-166 |     81 |<br>+—–+——-+——–+</p><h5 id="查询不包含某个字符"><a href="#查询不包含某个字符" class="headerlink" title="查询不包含某个字符"></a>查询不包含某个字符</h5><p><code>select * from student where sname not like &#39;王%&#39; and sname not like &#39;wang%&#39;;</code></p><p>用not like就行</p><p>结果</p><p>+—–+———–+——+————+——-+<br>| sno | sname     | ssex | sbirth     | class |<br>+—–+———–+——+————+——-+<br>| 101 | 曾华      | 男   | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男   | 1975-10-02 | 95031 |<br>| 104 | 李军      | 男   | 1976-02-20 | 95033 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     |<br>| 106 | 陆军      | 男   | 1974-06-03 | 95031 |<br>| 108 | znehua    | man  | 1997-09-01 | 1     |<br>| 109 | lijun     | man  | 1996-08-11 | 3     |<br>+—–+———–+——+————+——-+</p><h5 id="查询年龄，运用now"><a href="#查询年龄，运用now" class="headerlink" title="查询年龄，运用now"></a>查询年龄，运用now</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname, <span class="keyword">year</span>(<span class="keyword">now</span>())-<span class="keyword">year</span>(sbirth) <span class="keyword">as</span> age</span><br><span class="line"><span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>结果</p><p>+———–+——+<br>| sname     | age  |<br>+———–+——+<br>| 曾华      |   43 |<br>| 匡明      |   45 |<br>| 王丽      |   44 |<br>| 李军      |   44 |<br>| kuangming |   23 |<br>| 陆军      |   46 |<br>| wangli    |   22 |<br>| znehua    |   23 |<br>| lijun     |   24 |<br>+———–+——+</p><h5 id="子查询嵌套"><a href="#子查询嵌套" class="headerlink" title="子查询嵌套"></a>子查询嵌套</h5><p>查询选修计算机导论的女同学成绩表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">where</span> cno = (</span><br><span class="line"><span class="keyword">select</span> cno <span class="keyword">from</span> course</span><br><span class="line">    <span class="keyword">where</span> cname = <span class="string">'计算机导论'</span></span><br><span class="line">) <span class="keyword">and</span> sno <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> ssex = <span class="string">'女'</span> <span class="keyword">or</span> ssex = <span class="string">'woman'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结果</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 103 | 3-105 |     92 |<br>+—–+——-+——–+</p><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><p><strong>内联查询</strong> <code>inner join....on</code> ：</p><p><code>select * from student a inner join score b on a.sno = b.sno;</code> </p><p>结果</p><p>+—–+———–+——+————+——-+—–+——-+——–+<br>| sno | sname     | ssex | sbirth     | class | sno | cno   | degree |<br>+—–+———–+——+————+——-+—–+——-+——–+<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 103 | 3-105 |     92 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 103 | 3-245 |     86 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 103 | 6-166 |     85 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 105 | 3-105 |     88 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 105 | 3-245 |     75 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 105 | 6-166 |     79 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 109 | 3-105 |     76 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 109 | 3-245 |     68 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 109 | 6-166 |     81 |<br>+—–+———–+——+————+——-+—–+——-+——–+</p><p>就是按照id把两个表放一起。需要两个表里都有相同的id</p><p><strong>左外连接</strong> <code>left join.....on</code>：</p><p><code>select * from student a left join score b on a.sno = b.sno;</code></p><p>结果</p><p>+—–+———–+——-+————+——-+——+——-+——–+<br>| sno | sname     | ssex  | sbirth     | class | sno  | cno   | degree |<br>+—–+———–+——-+————+——-+——+——-+——–+<br>| 101 | 曾华      | 男    | 1977-09-01 | 95033 | NULL | NULL  |   NULL |<br>| 102 | 匡明      | 男    | 1975-10-02 | 95031 | NULL | NULL  |   NULL |<br>| 103 | 王丽      | 女    | 1976-01-23 | 95033 | 103  | 3-105 |     92 |<br>| 103 | 王丽      | 女    | 1976-01-23 | 95033 | 103  | 3-245 |     86 |<br>| 103 | 王丽      | 女    | 1976-01-23 | 95033 | 103  | 6-166 |     85 |<br>| 104 | 李军      | 男    | 1976-02-20 | 95033 | NULL | NULL  |   NULL |<br>| 105 | kuangming | man   | 1997-10-01 | 2     | 105  | 3-105 |     88 |<br>| 105 | kuangming | man   | 1997-10-01 | 2     | 105  | 3-245 |     75 |<br>| 105 | kuangming | man   | 1997-10-01 | 2     | 105  | 6-166 |     79 |<br>| 106 | 陆军      | 男    | 1974-06-03 | 95031 | NULL | NULL  |   NULL |<br>| 107 | wangli    | woman | 1998-05-01 | 3     | NULL | NULL  |   NULL |<br>| 108 | znehua    | man   | 1997-09-01 | 1     | NULL | NULL  |   NULL |<br>| 109 | lijun     | man   | 1996-08-11 | 3     | 109  | 3-105 |     76 |<br>| 109 | lijun     | man   | 1996-08-11 | 3     | 109  | 3-245 |     68 |<br>| 109 | lijun     | man   | 1996-08-11 | 3     | 109  | 6-166 |     81 |<br>+—–+———–+——-+————+——-+——+——-+——–+</p><p>左边的表有和右边表相同id就列出来，没有就标为null。</p><p><strong>右外连接</strong> <code>right join....on</code>：与上面相反。</p><p>*<em>MySQL不支持全连接 <code>full join</code> *</em>：就是把左右连接和在一起。</p><p><strong>自然连接</strong> <code>natural join</code>：</p><p><code>select * from student natural join score;</code></p><p>结果</p><p>+—–+———–+——+————+——-+——-+——–+<br>| sno | sname     | ssex | sbirth     | class | cno   | degree |<br>+—–+———–+——+————+——-+——-+——–+<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 3-105 |     92 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 3-245 |     86 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 6-166 |     85 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 3-105 |     88 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 3-245 |     75 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 6-166 |     79 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 3-105 |     76 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 3-245 |     68 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 6-166 |     81 |<br>+—–+———–+——+————+——-+——-+——–+</p><p>不需要指定连接条件，MySQL会自动使用表内相同的字段把两个表连接在一起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些查询语句，防止忘记。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MySQL" scheme="https://heronking.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库的三大范式</title>
    <link href="https://heronking.gitee.io/archives/e7b99fed.html"/>
    <id>https://heronking.gitee.io/archives/e7b99fed.html</id>
    <published>2020-03-20T07:27:43.000Z</published>
    <updated>2020-03-20T08:34:34.379Z</updated>
    
    <content type="html"><![CDATA[<p>在进行数据库设计的时候应该满足三大范式。书上写的晕头转向，记一下理解。</p><p>三大范式具体如下：</p><ul><li>第一范式 1NF，确保每一列的<strong>原子性</strong>。</li><li>第二范式 2NF，在1NF的基础上，确保表中的<strong>每列都和主键相关</strong>，而且是完全依赖。</li><li>第三范式 3NF，在2NF的基础上，确保<strong>每列数据都和主键直接相关，不能是间接相关</strong>，即消除传递依赖。</li></ul><a id="more"></a><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>先上个表</p><table><thead><tr><th>ID</th><th>Name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>深圳市福田区xxxx</td></tr><tr><td>2</td><td>李四</td><td>长沙市岳麓区xxxx</td></tr></tbody></table><p>这个表不满足，因为地址还能拆分成城市和地区。可拆分，那就不是原子的。</p><p>虽然第一范式要求是原子的，但有些时候也不是一定要拆。在你需要对城市进行区分的时候，才需要拆，如果不需要通过地址进行分类，反而能提升性能。</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>满足第一范式，其他每一列都<strong>必须完全依赖于</strong>主键，啥叫完全依赖？当主键是联合主键的时候，其他列和这个联合主键中的每一个都有关系。</p><p>比如说：</p><p>这个表的主键是（订单id和顾客id）</p><table><thead><tr><th align="center">订单id</th><th align="center">商品id</th><th align="center">商品信息</th><th align="center">顾客</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">抱枕</td><td align="center">张三</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">被子</td><td align="center">李四</td><td align="center">6</td></tr></tbody></table><p>显然，商品信息只和商品id有关，和订单还有顾客没啥关系，那么这就违反了2NF。</p><p>要满足2NF，那就需要拆表：</p><p>这是个订单表，主键是订单id，其他id是外键</p><table><thead><tr><th align="center">订单id</th><th align="center">商品id</th><th align="center">顾客id</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">6</td></tr></tbody></table><p>商品表</p><table><thead><tr><th align="center">商品id</th><th align="center">商品信息</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">抱枕</td></tr><tr><td align="center">2</td><td align="center">被子</td></tr></tbody></table><p>顾客信息</p><table><thead><tr><th align="center">顾客id</th><th align="center">顾客名</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td></tr><tr><td align="center">2</td><td align="center">李四</td></tr></tbody></table><p>拆完之后他们就各自满足2NF了。</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>满足第二范式，不存在传递依赖，啥叫传递依赖？</p><p>a = b，b = c，a = c，这个叫传递，= 换成依赖，那就是传递依赖。</p><p>比如说上面那个订单信息表再加一列</p><table><thead><tr><th align="center">订单id</th><th align="center">商品id</th><th align="center">顾客id</th><th align="center">性别</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">男</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">女</td><td align="center">6</td></tr></tbody></table><p>很明显订单id和性别没什么关系，性别是依赖于顾客的，根据传递依赖我们得出订性别依赖于订单id，那么这就不满足3NF。</p><p>这里很好解决，把性别放到顾客信息就行了。</p><table><thead><tr><th align="center">顾客id</th><th align="center">顾客名</th><th align="center">性别</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">女</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行数据库设计的时候应该满足三大范式。书上写的晕头转向，记一下理解。&lt;/p&gt;
&lt;p&gt;三大范式具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式 1NF，确保每一列的&lt;strong&gt;原子性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第二范式 2NF，在1NF的基础上，确保表中的&lt;strong&gt;每列都和主键相关&lt;/strong&gt;，而且是完全依赖。&lt;/li&gt;
&lt;li&gt;第三范式 3NF，在2NF的基础上，确保&lt;strong&gt;每列数据都和主键直接相关，不能是间接相关&lt;/strong&gt;，即消除传递依赖。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://heronking.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装</title>
    <link href="https://heronking.gitee.io/archives/8b39915a.html"/>
    <id>https://heronking.gitee.io/archives/8b39915a.html</id>
    <published>2020-03-19T10:42:58.000Z</published>
    <updated>2020-03-19T11:05:11.547Z</updated>
    
    <content type="html"><![CDATA[<p>装mysql的时候遇到很多坑。</p><p>弄的是免安装版的，所以需要各种奇奇怪怪的配置。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>从官网 <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载</a> </p><a id="more"></a><p><img src="/archives/8b39915a/1.png" alt></p><p>下这个版本就行了。但是速度巨慢，基本上没有个一下午是弄不完的</p><p>我是从 <a href="http://mirrors.sohu.com/mysql/MySQL-8.0/" target="_blank" rel="noopener">镜像</a> 下载的</p><p><img src="/archives/8b39915a/2.png" alt></p><p>速度起飞。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>把下好的压缩包解压到好了以后，在目录下新建一个文件 <code>my.ini</code> ，这就是你的配置文件。内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port=3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\\MySQL</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=D:\\MySQL\\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 允许连接失败的次数。</span><br><span class="line">max_connect_errors=10</span><br><span class="line"># 服务端使用的字符集默认为utf8mb4</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"># 默认使用“mysql_native_password”插件认证</span><br><span class="line">#mysql_native_password</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure><p><strong>注意，data文件夹不能自己建立</strong>。</p><h4 id="安装、初始化、启动服务"><a href="#安装、初始化、启动服务" class="headerlink" title="安装、初始化、启动服务"></a>安装、初始化、启动服务</h4><p>首先用管理员身份打开cmd</p><p>然后通过cd 进入MySQL的bin目录</p><p>然后输入咒语：<code>mysqld --install</code>，出现 <code>Service successfully installed</code></p><p>下一个咒语： <code>mysqld --initialize --console</code> ，然后就会出现一堆代码，那里面有一段是 <code>password is generated for root@localhost：xxxxxx</code>。运用我们的小学二年级英语，就知道了这个东西是密码。</p><p><strong>记住密码</strong></p><p>接下来使用咒语：<code>net start mysql</code>，启动mysql</p><p>先别关闭。</p><h4 id="登录并修改密码"><a href="#登录并修改密码" class="headerlink" title="登录并修改密码"></a>登录并修改密码</h4><p>接着上面使用咒语：<code>mysql -u root -p</code>，回车以后就提示输入Enter password</p><p>把刚刚的密码输入进去回车，这样就可以开始用MySQL。</p><p>改密码写SQL就行了： <code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;密码&#39;;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装mysql的时候遇到很多坑。&lt;/p&gt;
&lt;p&gt;弄的是免安装版的，所以需要各种奇奇怪怪的配置。&lt;/p&gt;
&lt;h4 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h4&gt;&lt;p&gt;从官网 &lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://heronking.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>java集合简单总结</title>
    <link href="https://heronking.gitee.io/archives/f5e78ffc.html"/>
    <id>https://heronking.gitee.io/archives/f5e78ffc.html</id>
    <published>2020-03-18T13:37:17.000Z</published>
    <updated>2020-03-19T06:38:43.914Z</updated>
    
    <content type="html"><![CDATA[<p>java中的集合框架主要分为两类：Collection 和 Map</p><ul><li>Collection 是单列集合，Map是双列</li><li>Collection中的Set要求集合元素唯一，Map中的键值为一，值没有限制</li></ul><a id="more"></a><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><ul><li><p>List</p><ul><li>ArrayList：Object数组</li><li>LinkedList：双向链表（JDK1.7取消了循环链表）</li><li>Vector：已过时，被ArrayList取代</li></ul></li><li><p>Set</p><ul><li>HashSet：无序且元素唯一，使用哈希法存储元素，底层是HashMap。</li><li>LinkedHashSet：继承于HashSet，但底层是LinkedHashMap。存取<strong>有顺序</strong>，元素唯一，即存进的顺序和取出来的顺序是一样的。</li><li>TreeSet：就是一棵红黑树（自平衡的排序二叉树），存取无序，但自动排序，这是红黑树的特点。</li></ul></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li>HashMap：<a href="https://heronking.github.io/archives/166dc6bc.html" target="_blank" rel="noopener">详情</a> ，使用数组 + 链表/红黑树 的哈希表结构，存储的是Entry键值对。</li><li>LinkedHashMap：继承于HashMap，底层结构在HashMap的基础上<strong>增加了一条双向链表</strong>，用来保持键值对的插入顺序，所以它存取有序。</li><li>TreeMap：红黑树，可以通过实现Comparator接口来指定排序方法。</li><li>Hashtable：与HashMap功能类似，数组 + 链表组成，不能存有null的键值。线程安全，但不推荐使用。多线程使用ConcurrentHashMap</li></ul><h4 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h4><p>根据集合特点来选。</p><p>如果需要用到键值，那自然就选Map，根据具体情况来选某一个Map，比如需要排序就用TreeMap，不需要排序就用HashMap，需要保证线程安全就用ConcurrentHashMap。</p><p>如果只需要用来存放元素，那就用Collection，需要元素唯一就用Set，不需要就用List。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中的集合框架主要分为两类：Collection 和 Map&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection 是单列集合，Map是双列&lt;/li&gt;
&lt;li&gt;Collection中的Set要求集合元素唯一，Map中的键值为一，值没有限制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>简述HashMap的工作原理</title>
    <link href="https://heronking.gitee.io/archives/166dc6bc.html"/>
    <id>https://heronking.gitee.io/archives/166dc6bc.html</id>
    <published>2020-03-18T09:31:07.000Z</published>
    <updated>2020-03-24T06:13:44.695Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是java中运用特别多的数据结构，写一点面试的时候可能会用到的知识。</p><p>JDK1.8以后 hashMap 的底层经过了优化，在1.8以前是使用<strong>挂链式</strong>解决 <a href="https://heronking.github.io/archives/1293cfc0.html" target="_blank" rel="noopener">哈希冲突</a> 。优化之后，当链表的长度大于一个阈值（默认是8），那么存储哈希冲突的链表会转为红黑树，优化查找时间为O(lgn)。</p><p>为什么是8呢？</p><a id="more"></a><p>如果这个阈值设置太小，相同的哈希数量频繁达到阈值，那么底层就会频繁的在链表和红黑树之间转换。哈希冲突的概率满足泊松分布，同样的哈希值达到8的概率非常小。</p><p>HashMap底层用到的哈希表结构是这样的（<a href="https://www.jianshu.com/p/54d5c2b58125" target="_blank" rel="noopener">图源</a>）：</p><img src="/archives/166dc6bc/1.png" alt="哈希表" style="zoom:80%;"><p>可以看到，如果存储的数据没有哈希冲突，那么这个哈希表就是一个根据哈希值来存储的散列数组。</p><h4 id="HashMap的工作原理是什么？"><a href="#HashMap的工作原理是什么？" class="headerlink" title="HashMap的工作原理是什么？"></a>HashMap的工作原理是什么？</h4><p>我们使用 <code>put(key, value)</code> 的方式存储对象到HashMap中，使用 <code>get(key)</code> 方法从HashMap中获得对象。</p><p>当存数据的时候，HashMap首先会对键值使用哈希函数 ，此时函数返回的值就是哈希表中的一个bucket位置（图中存放Entry的就是bucket，上面有6个）来存储Entry对象。</p><p>Entry对象是一个静态内部类，里面有属性key、value 和 next，对于每一个需要存储的键值对，HashMap都把他们放到Entry里面。</p><h4 id="当要存储的两个对象哈希码值相同会发生什么？"><a href="#当要存储的两个对象哈希码值相同会发生什么？" class="headerlink" title="当要存储的两个对象哈希码值相同会发生什么？"></a>当要存储的两个对象哈希码值相同会发生什么？</h4><p>也就是哈希冲突发生了。</p><p>由于哈希码值相同，那么他们会找到同一个bucket，然后对两个Entry的调用<code>equals()</code>方法。</p><p>如果返回的是false，那么就将这两个对象存放的Entry组成一个链表，然后把链表的头节点放在bucket中，如上图一样。此时 <code>put()返回的是null</code>，因为插入的是一个新的值。</p><p>如果 <code>equals()</code>方法返回true，说明HashMap中已经存在真正一样的key，此时原来键值对中value，会被替换成新插入的value，<code>put()</code> 方法返回的是原来键值对中的value。</p><p>比如HashMap中已经存在<code>&lt;1, &quot;aaa&quot;&gt;</code> ，那么执行 <code>put(1, &quot;bbb&quot;)</code>，HashMap中就变成了 <code>&lt;1, &quot;bbb&quot;&gt;</code> ，然后put方法返回的是 “aaa”。</p><h4 id="怎么取出哈希码相同的某一个值对象？"><a href="#怎么取出哈希码相同的某一个值对象？" class="headerlink" title="怎么取出哈希码相同的某一个值对象？"></a>怎么取出哈希码相同的某一个值对象？</h4><p>直接查找存储在bucket中的链表，使用 <code>key.equals(Entry.key)</code> 来判断是否找到，最后返回对应的value对象即可。如果链表特别长，那么查找的效率会非常低，因此优化为红黑树，提高效率。</p><h4 id="HashMap的大小超过了负载因子怎么办？"><a href="#HashMap的大小超过了负载因子怎么办？" class="headerlink" title="HashMap的大小超过了负载因子怎么办？"></a>HashMap的大小超过了负载因子怎么办？</h4><p>hashMap默认的负载因子(load factor)是0.75，也就是说，如果数据<strong>填满了75%的bucket数组</strong>，那么就是超过了负载因子。</p><p>HashMap就会创建一个新的 <strong>2 * 原capacity (默认16，可自己定义)</strong> 大小的bucket数组，并将原数组中的所有对象都放到这个新的里面。</p><p>这个过程叫做rehash，原数组的每一个对象需要<strong>重新hash</strong>才能放到新的bucket数组中。因为HashMap计算哈希码的方法是： <code>hashCode &amp; (n - 1)（n是新的bucket数组长度）</code>。 </p><h4 id="多线程下重新调整HashMap的大小有什么问题？"><a href="#多线程下重新调整HashMap的大小有什么问题？" class="headerlink" title="多线程下重新调整HashMap的大小有什么问题？"></a>多线程下重新调整HashMap的大小有什么问题？</h4><p>HashMap是非线程安全的，在多线程下会产生资源竞争。在<strong>JDK1.7</strong>中因为rehash而迁移的链表元素会全部倒置，如果此时条件竞争发生，那么就会出现循环链表，查询循环链表会形成死锁。</p><p>但JDK1.8已经解决了这个，因为链表迁移不会再倒置了。</p><p>但还是不建议在多线程下使用。</p><h4 id="为什么wrapper类更适合作为键值？"><a href="#为什么wrapper类更适合作为键值？" class="headerlink" title="为什么wrapper类更适合作为键值？"></a>为什么wrapper类更适合作为键值？</h4><p>因为String、Integer这些wrapper类是用final修饰的，是不可变的，而且这些类中已经重写过了 <code>equals() 和 hashCode()</code> 方法。</p><p>不变这个条件是必要的，因为hashMap需要计算key的hashcode，那就必须防止键值改变，如果键值在 <code>put()</code> 完成以后，再用 <code>get()</code> 调用的时候返回的是不同的hashcode，那么就找不到这个key对应的value了。</p><p>正确的重写那两个方法也是必要的。一个好的hashCode()方法也能提高HashMap的性能，减少哈希冲突。</p><h4 id="自定义对象是否可以作为键值？"><a href="#自定义对象是否可以作为键值？" class="headerlink" title="自定义对象是否可以作为键值？"></a>自定义对象是否可以作为键值？</h4><p>只要该对象满足上面所说的wrapper类的条件就能作为键值。</p><p><strong>ConcurrentHashMap 和 Hashtable 区别</strong></p><p>ConcurrentHashMap的同步性能比Hashtable更好，因为它只对map的一部分上锁，属于分段锁，对整个bucket数组都进行了分割，每一把锁都只锁一部分数据。这样可以避免多线程出现锁竞争，提高并发访问率。</p><p>因此Hashtable提供更强的线程安全性，用的是一把锁，竞争越激烈效率越低。</p><p>一般来说都是用ConcurrentHashMap来替代Hashtable，Hashtable已经基本被淘汰了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap是java中运用特别多的数据结构，写一点面试的时候可能会用到的知识。&lt;/p&gt;
&lt;p&gt;JDK1.8以后 hashMap 的底层经过了优化，在1.8以前是使用&lt;strong&gt;挂链式&lt;/strong&gt;解决 &lt;a href=&quot;https://heronking.github.io/archives/1293cfc0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;哈希冲突&lt;/a&gt; 。优化之后，当链表的长度大于一个阈值（默认是8），那么存储哈希冲突的链表会转为红黑树，优化查找时间为O(lgn)。&lt;/p&gt;
&lt;p&gt;为什么是8呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线程、进程、程序的区别和联系</title>
    <link href="https://heronking.gitee.io/archives/d680fc0.html"/>
    <id>https://heronking.gitee.io/archives/d680fc0.html</id>
    <published>2020-03-17T14:03:25.000Z</published>
    <updated>2020-03-17T15:12:54.585Z</updated>
    
    <content type="html"><![CDATA[<p>线程是比进程更小的<strong>执行单位</strong>。进程是<strong>线程的容器</strong>，是程序的<strong>基本执行实体</strong>。</p><h4 id="什么是程序？"><a href="#什么是程序？" class="headerlink" title="什么是程序？"></a>什么是程序？</h4><blockquote><p>程序是含有指令和数据的文件，被存储在磁盘上，其本身是一堆静态的代码。</p></blockquote><a id="more"></a><p>程序是作为一种软件资料长期存在的，说白了就是个文件。只要不动它，它就只能在那什么也做不了。从某种意义上讲，程序是永久的。</p><p><strong>程序是不能单独执行的</strong>，只有把程序加载到内存中，系统为它分配资源后才能执行，而这种执行中的程序就是进程。</p><h4 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h4><blockquote><p>进程是程序的一次执行过程，是系统运行程序的基本单位，所以进程是一个动态的概念。</p></blockquote><p>一个进程就是一个执行中的程序，它占用着系统的资源，比如CPU时间、内存、文件、I/O设备的使用权等等。</p><p>进程是有生命周期的，当进程终止以后，就需要系统再次分配资源执行程序才能创建新的进程。</p><p>程序可以对应多个进程，而且这些进程之间是相互独立的。</p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><blockquote><p>进程是系统分配资源和调度的基本单位，而线程是CPU调度和分派的基本单位。</p></blockquote><p>一个进程中可以包含若干个线程，这些线程之间是共享资源的。所以线程是进程的更小划分。</p><p>进程在执行过程中拥有自己独立的系统资源和内存。而线程在运行时基本不拥有系统资源，只是暂用一些计数器、寄存器和栈。</p><p>系统产生线程或者在各个线程之间切换时，负担和消耗比进程要小得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程是比进程更小的&lt;strong&gt;执行单位&lt;/strong&gt;。进程是&lt;strong&gt;线程的容器&lt;/strong&gt;，是程序的&lt;strong&gt;基本执行实体&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;什么是程序？&quot;&gt;&lt;a href=&quot;#什么是程序？&quot; class=&quot;headerlink&quot; title=&quot;什么是程序？&quot;&gt;&lt;/a&gt;什么是程序？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;程序是含有指令和数据的文件，被存储在磁盘上，其本身是一堆静态的代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
      <category term="线程" scheme="https://heronking.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的基本状态与生命周期</title>
    <link href="https://heronking.gitee.io/archives/70ca885c.html"/>
    <id>https://heronking.gitee.io/archives/70ca885c.html</id>
    <published>2020-03-17T09:22:03.000Z</published>
    <updated>2020-03-25T07:36:01.204Z</updated>
    
    <content type="html"><![CDATA[<p>开门见山！参考自 <a href="https://blog.csdn.net/pange1991/article/details/53860651?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">博客</a> 。</p><p>线程的基本状态有6种，java线程在生命周期中的某一个指定时刻只可能处于一种状态。</p><p>先看看有哪6中状态</p><a id="more"></a><blockquote><table><thead><tr><th align="center">状态名</th><th>说   明</th></tr></thead><tbody><tr><td align="center">初始态（New）</td><td>线程被构建，但还没有调用 <code>start()</code> 方法</td></tr><tr><td align="center">运行态（Runnable）</td><td>java线程将就绪态（ready）和运行中（running）两种状态统称为运行态。<br>线程对象创建并调用 <code>start()</code> 方法之后，该线程就位于可运行线程池中，等待系统调度。这个状态叫就绪态（ready）。<br>就绪态的线程在获得 CPU时间片之后就会开始执行，此时线程就处于运行中（running）</td></tr><tr><td align="center">阻塞态（Blocked）</td><td>线程阻塞于锁</td></tr><tr><td align="center">等待态（waiting）</td><td>进入该状态的线程表示当前线程需要等待其他线程做出一些特定动作（比如通知或中断）</td></tr><tr><td align="center">超时等待（Time_Waiting）</td><td>该状态不同于等待态，它可以在指定的时间后自行返回。</td></tr><tr><td align="center">终止态（Terminated）</td><td>线程已经执行完毕</td></tr></tbody></table></blockquote><p><strong>源码在Thread类的State中。</strong></p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>看图说话，这张图（<a href="https://www.cnblogs.com/aspirant/p/8900276.html" target="_blank" rel="noopener">来源</a>）详细的记录了Java线程之间的切换：</p><p><img src="/archives/70ca885c/1.jpg" alt="线程之间的切换"></p><p>还有简单版（<a href="https://blog.csdn.net/huakai_sun/article/details/78287931" target="_blank" rel="noopener">来源</a>）的：</p><p><img src="/archives/70ca885c/2.jpg" alt="线程切换"></p><h4 id="初始态"><a href="#初始态" class="headerlink" title="初始态"></a>初始态</h4><p>实现Runnable接口或者继承Thread可以得到线程类，使用new实例化以后，线程就进入了初始态。此时的线程情况是：</p><ul><li>JVM为该线程分配内存，初始化成员变量</li><li>线程对象没有表现出线程的动态特征，程序不会执行线程的内容。</li></ul><h4 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h4><p>就绪态的线程不会立即执行，而是在<strong>可运行线程池</strong>中<strong>等待CPU调度，为其分配CPU时间片</strong>以后才会开始执行，进入运行中状态。</p><p>让线程进入就绪态的情况，图上已经有标识了</p><ul><li>实例对象调用 <code>start()</code> 方法，线程进入就绪态。</li><li>各种各样的阻塞（sleep、join、用户I/O）完成之后、锁池中的线程拿到对象锁（还是因为阻塞），线程会回到就绪态</li><li>当前线程的时间片用完了、或者调用 <code>yield()</code> <strong>让出CPU调度</strong>，线程回到就绪态。这里是从运行态回到就绪态</li></ul><h4 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h4><p>线程调度从可运行线程池（处于就绪态的线程们）中选择一个线程调用并分配资源，那么该线程就会进入运行态。<strong>这是线程进入运行态的唯一途经</strong>。</p><p>此时，自动调用该线程对象的 <code>run()</code> 方法，而 <code>run()</code>方法内定义了这个线程功能。</p><p>若此时调用 <code>yeild()</code> 方法，线程会<strong>让出CPU</strong>，重新回到就绪态，也可能会发生刚回去又马上分配到资源再次执行的情况。</p><h4 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h4><p>一个正在运行的线程在特殊情况下，会让出自己的资源并暂时中止，这就是阻塞。</p><p>阻塞态可以分为三种：</p><ul><li><p><strong>等待阻塞</strong>，线程调用 <code>wait()</code> 方法，该线程<strong>释放CPU也释放锁</strong>并进入等待队列中等待被再次唤醒（其他线程调用 <code>notify()</code> 方法随机唤醒一个，调用 <code>notifyAll()</code> 方法唤醒全部，或者线程结束后自动唤醒）。唤醒后会放入锁池队列中和其他线程竞争同步锁。<strong>这个状态就是java线程里的等待态</strong>。</p></li><li><p><strong>同步阻塞</strong>，线程遇到同步锁，但锁被其他线程占用，该线程进入锁池转为同步阻塞，与其他线程竞争同步锁。当再次获取到锁，线程进入就绪态。</p></li><li><p><strong>其他阻塞</strong>，有几种情况：</p><ul><li><p>线程调用 <code>sleep()</code> 方法，该线程<strong>释放CPU但不释放锁</strong>，线程会抱着锁开始睡觉，等待sleep时间到或者调用了 <code>interrupt()</code> 方法才会结束。<br><strong>这里在java中也被称为超时等待态</strong>，相当于在 <strong>等待态</strong> 的基础上增加了超时限制，一般通过 sleep(long s) 和 wait(long s) 让程序进入超时等待。当时间到了之后，线程进入就绪态。</p></li><li><p>当前线程调用另一个线程的 <code>join()</code> 方法，比如 <code>t2.join()</code>，那么当前线程 t 进入阻塞，直到 t2 结束。</p></li><li><p>等待用户的I/O操作，当前线程进入阻塞。</p></li></ul></li></ul><p><strong>再次注意，阻塞结束后，线程会回到就绪态。</strong></p><h4 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h4><p>线程调用 <code>stop()</code> 方法、<code>destroy()</code> 方法、遇到异常终止、线程正常执行完也就是 <code>run()</code> 方法执行结束后，线程死亡。</p><p><strong>处于终止态的线程不再具备运行能力</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开门见山！参考自 &lt;a href=&quot;https://blog.csdn.net/pange1991/article/details/53860651?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;线程的基本状态有6种，java线程在生命周期中的某一个指定时刻只可能处于一种状态。&lt;/p&gt;
&lt;p&gt;先看看有哪6中状态&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
      <category term="线程" scheme="https://heronking.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>equals和hashCode</title>
    <link href="https://heronking.gitee.io/archives/333b0902.html"/>
    <id>https://heronking.gitee.io/archives/333b0902.html</id>
    <published>2020-03-17T07:19:10.000Z</published>
    <updated>2020-03-18T10:11:40.107Z</updated>
    
    <content type="html"><![CDATA[<p>在java中有一个基础方法 <code>hashCode()</code>，和 <code>equals() toString()</code> 一样，是 Object类 里面的方法，嗯，Object是所有类的老父亲。</p><p>从某种严格的意义上讲，每一个java类都需要重写这三个方法。不过一般不这么干，用不到就不重写。</p><a id="more"></a><h4 id="关于hashCode的介绍"><a href="#关于hashCode的介绍" class="headerlink" title="关于hashCode的介绍"></a>关于hashCode的介绍</h4><p>其实hashCode()就是 <a href="https://heronking.github.io/archives/1293cfc0.html" target="_blank" rel="noopener">哈希表</a> 的散列函数，它的返回值就是hash码，那个传说中的key值，嗯，是个int型的。</p><p>它的存在就是为了哈希表服务的。</p><p>java中有两种<strong>集合</strong>，一类是List，一类是Set。我们在小学二年级的时候就学过集合的概念，不过在计算机语言中，集合是一种数据结构。</p><p>这里说一下HashSet这个集合，它是Set的一个子类，它也比较接近数学中的集合，存储在它里面的元素<strong>无序且不可重复的</strong>。为什么是无序的呢？因为它是根据 <code>hashCode()</code> 返回的散列码来存储的。</p><p><strong>那么HashSet如何检查重复？</strong></p><p>在向HashSet中使用 <code>add()</code> 添加一个对象元素时，HashSet会先得到该元素调用hashCode()之后返回的散列码key，然后根据这个key值判断该元素应该存储的位置，<strong>若该位置已经有元素对象</strong>，那么就与已经添加元素的hashCode值作比较。</p><p>如果不同，那么HashSet就会认为该元素没有重复。</p><p>如果相同（<strong>注意这里只是hashCode的值相同</strong>），就要调用 <code>equals()</code> 方法来检查这两个对象是不是真的一样。最后如果返回了true，那么HashSet就认为两个元素重复，add操作就会返回false，加入失败。</p><p>这就是  <code>hashCode()</code> 的用途。</p><h4 id="重写-equals-的时候，也要重写hashCode"><a href="#重写-equals-的时候，也要重写hashCode" class="headerlink" title="重写 equals 的时候，也要重写hashCode"></a>重写 equals 的时候，也要重写hashCode</h4><p>通过上面集合的栗子可以看到，集合判断元素是否重复，需要同时用到equals和hashCode，如果其中一个被重写了，另一个必须做出相应的重写，不然就会出错。</p><p>这里有相关规定：</p><blockquote><ul><li>如果两个对象相等，则 hashCode 一定也是相同的</li><li>如果两个对象相等，那么对两个对象分别调用 equals 和 hashcode方法都会返回true</li><li>两个对象有相同的 hashcode值，但他们的不一定是相等的。</li><li>equals 方法被重写，则 hashcode也必须被重写</li><li>hashCode() 的默认行为是<strong>对堆上的对象产生独特的散列码值</strong>。如果没有重写 hashCode()，则该类的<strong>两个实例对象无论如何都不会相等</strong>，即使这两个对象指向相同的数据。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java中有一个基础方法 &lt;code&gt;hashCode()&lt;/code&gt;，和 &lt;code&gt;equals() toString()&lt;/code&gt; 一样，是 Object类 里面的方法，嗯，Object是所有类的老父亲。&lt;/p&gt;
&lt;p&gt;从某种严格的意义上讲，每一个java类都需要重写这三个方法。不过一般不这么干，用不到就不重写。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>理解哈希表</title>
    <link href="https://heronking.gitee.io/archives/1293cfc0.html"/>
    <id>https://heronking.gitee.io/archives/1293cfc0.html</id>
    <published>2020-03-17T06:13:48.000Z</published>
    <updated>2020-03-17T15:07:04.235Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表是一个用途十分广泛的数据结构，也叫散列表。散列的意思就是，散装排列嘛，把一些要存储的数据散列地放到表里面。</p><a id="more"></a><p>为什么要有哈希表呢？</p><p>先看看我们常用的数据结构</p><p><strong>普通数组</strong>：对数据的寻址简单且效率高，但插入和删除效率低。<br><strong>链表</strong>：对数据的插入和删除效率高，但寻址的效率低，平衡树的查找也需要O(lgn)。</p><p>而哈希表就是查询、插入、删除一般都只需要O(1)复杂度的数据结构。</p><p>对比其他数据结构，有张图：</p><img src="/archives/1293cfc0/1.png" alt="数据结构复杂度" style="zoom:75%;"><h4 id="哈希表的实现原理"><a href="#哈希表的实现原理" class="headerlink" title="哈希表的实现原理"></a>哈希表的实现原理</h4><p>哈希表的核心机制是<strong>散列函数</strong>。我们在小学二年级的时候就学过，什么叫函数。<br>函数是一种映射，即<strong>一对一</strong>，或者<strong>多对一</strong>的关系。不能一对多！</p><p>当然，这里的散列函数期望的是<strong>一对一</strong>的关系。在存储某一个数据的时候，我们把数据放到散列函数里面映射出一个key值，这个key值叫做哈希码，也就是散列码，而我们就是通过散列码来确定该数据在哈希表中的索引位置。</p><p>反之，如果知道了key值，就能直接检索到与之对应的数据。</p><p>哈希表也就实现了高效率存取。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>现在需要存储一组数据：14 16 5 58 42。</p><p>要哈希表来存储他们，首先呢，随便确定一个散列函数，<code>f(x) = x % 5</code> ，随便用的。</p><p>对于第一个数，<code>f(14) = 14 % 5 = 4</code> ，所以第一个数就是 <code>hash(4) = 14</code><br>第二个数，<code>f(16) = 16 % 5 = 1</code> ，那么 <code>hash(1) = 16</code><br>接下来，<code>hash(0)= 5    hash(3) = 58   hash(2) = 42</code> </p><p>存完了以后，接下来就是查找数据。这里是无序的，如果只是数组，那就得用for搜5次。</p><p>比如说我要在表内查一下16这个数据有没有，那么只需要看 <code>hash(16 % 5) == 16</code>，如果是true那自然就是有。</p><h4 id="哈希表的问题"><a href="#哈希表的问题" class="headerlink" title="哈希表的问题"></a>哈希表的问题</h4><p>前面说过，散列函数是<strong>期望</strong>一对一的关系，但是如果数据很多，再好的散列函数也可能出现多对一的情况，这个就是hash冲突。</p><p>解决hash冲突的方式一般有开放地址法、再哈希法、建立缓冲区</p><ul><li>挂链式，把产生冲突的hash地址指向一个单链表，这个链表存的就是具有相同key值的数据。而hash表中只存这个链表的头指针</li><li>缓冲区，把哈希表分为基本表和溢出表，和基本表发生hash冲突的数据放到溢出表中。</li><li>开放地址，对于冲突的key值，根据这个key在哈希表里面再找一个不冲突的地址</li><li>再哈希法，多整几个散列函数，多算几遍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表是一个用途十分广泛的数据结构，也叫散列表。散列的意思就是，散装排列嘛，把一些要存储的数据散列地放到表里面。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数据结构" scheme="https://heronking.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>==和equals</title>
    <link href="https://heronking.gitee.io/archives/cefdebd3.html"/>
    <id>https://heronking.gitee.io/archives/cefdebd3.html</id>
    <published>2020-03-16T13:42:58.000Z</published>
    <updated>2020-03-16T14:53:30.858Z</updated>
    
    <content type="html"><![CDATA[<p>在java中 <code>==</code> 和 <code>equals()</code> 是有一点点区别滴</p><p>直接上用法</p><a id="more"></a><h4 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a><code>==</code> 运算符</h4><p>这个运算符在使用时有两种情况：</p><ul><li>在两个基本数据类之间作比较时，比较的是两个数据的值是否相等。</li><li>两个对象之间作比较时，它判断是两个对象的地址是否相等。</li></ul><h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a><code>equals()</code> 方法</h4><p>同样也分两种情况：</p><ul><li><p>当该类没有重写 <code>equals()</code> 方法。那么该方法用于两个对象之间的比较时，等价于使用 <code>==</code>。</p></li><li><p>类重写了 <code>equals()</code> 方法。一般来说，都重写为用来比较两个对象的内容是否相等的形式，若相等则返回为 <code>true</code> ，也就认为这两个对象相等。</p><p>当然，具体的实现方法都由自己决定。</p></li></ul><p><strong>举个栗子说明一下</strong></p><p>先声明一下变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个基本数据类型</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">float</span> d = (<span class="keyword">float</span>) <span class="number">15.0</span>;</span><br><span class="line"><span class="comment">// 两个String对象，他们内容相同</span></span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);<span class="comment">//这个字符串会放到常量池中。在堆中new一个了String类，并在栈内创建了一个引用</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);<span class="comment">//在常量池中找到了"aaa"。在堆中new一个String类，并在栈内创建了一个新的引用。</span></span><br><span class="line"><span class="comment">// 两个字符串常量</span></span><br><span class="line">String aa = <span class="string">"aaa"</span>;<span class="comment">//在常量池中查找到</span></span><br><span class="line">String bb = <span class="string">"aaa"</span>;<span class="comment">//在常量池中查找到</span></span><br></pre></td></tr></table></figure><p>再用 <code>==</code> 和 <code>equals()</code> 方法对比一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aa == bb) &#123;</span><br><span class="line">System.out.println(<span class="string">"aa == bb"</span>);</span><br><span class="line">&#125;<span class="comment">//输出了aa == bb</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">System.out.println(<span class="string">"a == b"</span>);</span><br><span class="line">&#125;<span class="comment">//没有输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">System.out.println(<span class="string">"a equals b"</span>);</span><br><span class="line">&#125;<span class="comment">//输出了a equals b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">System.out.println(<span class="string">"c == d"</span>);</span><br><span class="line">&#125;<span class="comment">//输出了c == d</span></span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><p><strong>为什么没有输出 <code>a == b</code> 而输出了 <code>a equals b</code> 呢？</strong></p><p>这里需要说明一下，在 String 类中的 <code>equals()</code> 方法是<strong>已经被重写过的</strong>，所以这里使用的 <code>equals()</code> 其实比较的是内容。<br>所以输出 a equals b 也就不奇怪了，因为他们的内容相同。</p><p>而 a == b 这里的 <code>==</code> 比较的是两者的地址。</p><p>引用存放在 <a href="https://heronking.github.io/archives/eae4d02d.html" target="_blank" rel="noopener">栈区</a> ，a 是一个引用，指向的是对象<code>new String(&quot;aaa&quot;)</code>，b 是另一个引用，指向的是一个新的对象 <code>new String(&quot;aaa&quot;)</code>。他们是<strong>两个不同的对象</strong></p><p><strong>那么为什么输出了 aa == bb呢？</strong></p><p>因为当我们创建一个String类时，JVM会从常量池中查找是否存在内容和要创建的值相同的对象，如果存在的话，就会返回这个对象的引用。如果不存在，那么就会在常量池中创建一个新的String。</p><p> <code>String aa</code> 在常量池中找了”aaa”，那么 aa = “aaa”的引用<br><code>String bb</code> 也找到了，所以 bb = “aaa” 的引用</p><p>所以他们俩的地址是相等的。</p><p><strong>那么在内存中到底是啥样的呢？</strong></p><p>常量池：字符串”aaa”，只有这一个<br>堆：属于 a 的 new String(“aaa”)，属于 b 的 new String(“aaa”)</p><p>嗯。。基本数据类型就不写了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java中 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 是有一点点区别滴&lt;/p&gt;
&lt;p&gt;直接上用法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.gitee.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.gitee.io/tags/%E8%AE%B0/"/>
    
      <category term="面试" scheme="https://heronking.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
