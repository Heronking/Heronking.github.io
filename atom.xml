<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>这是个刚搭好的博客</title>
  <icon>https://www.gravatar.com/avatar/b23a4ea0e920b48f957291efdb1706bc</icon>
  <subtitle>弱小，可怜，无助</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://heronking.github.io/"/>
  <updated>2020-03-25T09:58:07.813Z</updated>
  <id>https://heronking.github.io/</id>
  
  <author>
    <name>多喝热水会好的</name>
    <email>wangliuaaa@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java反射机制</title>
    <link href="https://heronking.github.io/archives/3ecb78ee.html"/>
    <id>https://heronking.github.io/archives/3ecb78ee.html</id>
    <published>2020-03-25T06:00:03.000Z</published>
    <updated>2020-03-25T09:58:07.813Z</updated>
    
    <content type="html"><![CDATA[<p>在了解反射之前，要先知道什么是Class对象。</p><p>在java中对象分为两种：<strong>Class对象</strong>和<strong>实例对象</strong>。</p><p>实例对象是类的实例，用 <code>new</code> 来创建；</p><p>而Class对象，就是<strong>Class类的实例</strong>，嗯。。就是这么直接，在 <code>java.lang</code> 这个包下面，有一个类就叫Class。这个类内部可以记录其他类的成员、接口这些信息，也就是说，Class类是用来<strong>表示其他类的一个类</strong>。</p><a id="more"></a><p>java程序的执行需要经过<strong>编译、加载、链接、初始化</strong>这几个阶段。编译阶段JVM会将<code>.java</code>文件编译成 <code>.class</code> 文件，同时，在这个文件中生成Class对象。然后，JVM的加载机制会将Class对象加载到方法区中。</p><p>当我们需要实例化一个类的时候，JVM会在方法区中查看这个类的Class对象是否已经存在了，如果是，那么直接根据Class对象生成实例；如果没有，就先加载Class对象，再创建实例。</p><p><strong>在一个ClassLoader中只有一个Class对象</strong>（通常在一个JVM下只有一个ClassLoader），但可以根据这个Class对象创建多个对象实例。</p><h5 id="创建Class对象的方式"><a href="#创建Class对象的方式" class="headerlink" title="创建Class对象的方式"></a>创建Class对象的方式</h5><ul><li><code>类名.class</code> ，注意：<strong>这种方式在加载Class对象后不会初始化类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">"静态区域"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态代码块，如果初始化，静态代码块会执行</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = ClassTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果（在idea上）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk\bin\java.exe ...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line">什么都没输出</span><br></pre></td></tr></table></figure><ul><li><code>Class.forName()</code> 这种方法<strong>会初始化静态区域</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">"静态区域"</span>;</span><br><span class="line">    <span class="keyword">private</span> String m = <span class="string">"非静态"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态区域</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//非静态区域</span></span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.test.ClassTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk\bin\java.exe ...</span><br><span class="line">静态区域</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">只输出了静态区域的代码。</span><br></pre></td></tr></table></figure><p>可见，在加载Class对象到方法区，还将一起加载进来的静态方法初始化了。</p><ul><li><code>new class().getClass()</code> 这种方法是通过实例化对象调用的方式 get 到的Class对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String t = <span class="string">"静态区域"</span>;</span><br><span class="line">    <span class="keyword">private</span> String m = <span class="string">"非静态"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = ClassTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class.forName(<span class="string">"com.test.ClassTest"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"\n使用getClass："</span>);</span><br><span class="line">        <span class="keyword">new</span> ClassTest().getClass();</span><br><span class="line">        System.out.println(<span class="string">"实例化第二个："</span>);</span><br><span class="line">        <span class="keyword">new</span> ClassTest().getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\jdk\bin\java.exe ...</span><br><span class="line">静态区域</span><br><span class="line"></span><br><span class="line">使用getClass：</span><br><span class="line">非静态</span><br><span class="line">实例化第二个：</span><br><span class="line">非静态</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>把三种方法放到一起比较，对于类的初始化，静态区域在加载到方法区之后，只会初始化一次。而非静态区域每次实例化都会执行一次。</p><h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h4><p>以往都是通过new来创建对象，反射机制会获取到该类的Class对象，然后通过Class对象获取到构造器对象，然后再通过构造器对象创建一个对象。</p><p>new创建就是“正”着创建对象，在程序运行之前就已经确定了要new的类是哪一个。</p><p>而反射就是“反”着来，它是在<strong>运行时</strong>才知道需要操作的类是哪一个，并获取类的完整构造，并调用对应的方法</p><h5 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">       <span class="comment">//先获取Class对象，类名是Reflect</span></span><br><span class="line">       String className = <span class="string">"com.test.Reflect"</span>;</span><br><span class="line">       Class aClass = Class.forName(className);</span><br><span class="line">       <span class="comment">//再获取构造器对象，在Reflect类中必须有构造器，不然找不到</span></span><br><span class="line">       Constructor constructor = aClass.getConstructor();</span><br><span class="line">       <span class="comment">//通过构造器实例化对象</span></span><br><span class="line">       Reflect reflect = (Reflect) aClass.newInstance();</span><br><span class="line">       reflect.id = <span class="number">1</span>;</span><br><span class="line">       reflect.setName(<span class="string">"第一个"</span>);</span><br><span class="line">       System.out.println(reflect.getName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>需要注意的是：要实例化的类中必须写构造方法，不然会抛出异常 NoSuchMethodException</p><h5 id="通过反射访问属性"><a href="#通过反射访问属性" class="headerlink" title="通过反射访问属性"></a>通过反射访问属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">       String className = <span class="string">"com.test.Reflect"</span>;</span><br><span class="line">       Class aClass = Class.forName(className);</span><br><span class="line">       Constructor constructor = aClass.getConstructor();</span><br><span class="line">       Reflect reflect = (Reflect) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取id字段</span></span><br><span class="line">       Field field = reflect.getClass().getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">       <span class="comment">//修改id的值</span></span><br><span class="line">       field.set(reflect, <span class="number">2</span>);</span><br><span class="line">       System.out.println(<span class="string">"id的值："</span> + reflect.id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先实例化以后（实例化的方法随意），可以通过Class对象获取到该对象的属性并访问修改。</p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id的值：2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>注意 <code>getField() 和 getDeclareField()</code> 的区别</strong></p><ul><li><code>getField()</code> <strong>只能获取public的</strong>，包括<strong>继承过来的</strong>字段。</li><li><code>getDeclaredField()</code> 可以获取本类所有的字段，<strong>包括private</strong>的，但是<strong>不能获取继承</strong>来的字段。 (<strong>再注意</strong>： 这里<strong>只能获取到</strong>，但<strong>并不能访问</strong>该private字段的<strong>值</strong>,除非加上<strong>setAccessible(true)</strong>)</li></ul><h5 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, NoSuchFieldException, InvocationTargetException </span>&#123;</span><br><span class="line">       String className = <span class="string">"com.test.Reflect"</span>;</span><br><span class="line">       Class aClass = Class.forName(className);</span><br><span class="line">       Constructor constructor = aClass.getConstructor();</span><br><span class="line">       Reflect reflect = (Reflect) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过Class对象获取方法setName，第二参数是setName的参数类型</span></span><br><span class="line">       Method method = reflect.getClass().getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="comment">//对实例化对象调用获取到的方法</span></span><br><span class="line">       method.invoke(reflect, <span class="string">"反射调用方法"</span>);</span><br><span class="line">       System.out.println(<span class="string">"name的值："</span> + reflect.getName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name的值：反射调用方法</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h4 id="反射机制到底有什么用"><a href="#反射机制到底有什么用" class="headerlink" title="反射机制到底有什么用"></a>反射机制到底有什么用</h4><p>其实最主要的用途还是用来设计框架，达到解耦的目的，减少项目的维护成本。比如spring中的依赖注入，控制反转，就很好的用到了反射机制。</p><p>举个栗子：先准备两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买香蕉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<strong>new的方法</strong>话，如果我想买苹果，那就要 <code>new Apple().buyApple();</code> 但是，如果我不想买苹果了，我就要修改代码，先把买苹果删掉，然后写上 <code>new Banana().buyBanana();</code>，然后重新编译运行才能达到效果。</p><p>如果工程量很大呢？那业务层的代码要改很久，而且改了这个还可能对其他的业务造成影响。其实在Spring中提出的控制反转可以解决这个问题。</p><p><strong>这里使用反射机制</strong>，来实现一下</p><p>先创建一个txt文件放到src下面，内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class = com.test.Apple</span><br><span class="line">method = buyApple</span><br></pre></td></tr></table></figure><p>然后用反射机制开始操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//先读取文件到Properties</span></span><br><span class="line">        File fileOfSpring = <span class="keyword">new</span> File(<span class="string">"src/spring.txt"</span>);</span><br><span class="line">        Properties config = <span class="keyword">new</span> Properties();</span><br><span class="line">        config.load(<span class="keyword">new</span> FileInputStream(fileOfSpring));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制开展业务</span></span><br><span class="line">        <span class="comment">//先获取Class对象</span></span><br><span class="line">        Class aClass = Class.forName(config.getProperty(<span class="string">"class"</span>));</span><br><span class="line">        <span class="comment">//获取构造器</span></span><br><span class="line">        Constructor constructor =  aClass.getConstructor();</span><br><span class="line">        <span class="comment">//通过Class对象获取方法</span></span><br><span class="line">        Method method = aClass.getMethod(config.getProperty(<span class="string">"method"</span>));</span><br><span class="line">        <span class="comment">//实例一个Object对象</span></span><br><span class="line">        Object user = constructor.newInstance();</span><br><span class="line">        <span class="comment">//调用对象的方法，开展业务</span></span><br><span class="line">        method.invoke(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>不要忘记给类加上构造方法</strong></p><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">买苹果</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这个时候，如果我们想买香蕉怎么办？有反射机制，那就只需要更改spring.txt中配置就行了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class = com.test.Banana</span><br><span class="line">method = buyBanana</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">买香蕉</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>如果提供一个接口来配置spring.txt中的文件，把接口开放给用户，那就实现了Spring框架中的控制反转。</p><p>反射就是它的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解反射之前，要先知道什么是Class对象。&lt;/p&gt;
&lt;p&gt;在java中对象分为两种：&lt;strong&gt;Class对象&lt;/strong&gt;和&lt;strong&gt;实例对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实例对象是类的实例，用 &lt;code&gt;new&lt;/code&gt; 来创建；&lt;/p&gt;
&lt;p&gt;而Class对象，就是&lt;strong&gt;Class类的实例&lt;/strong&gt;，嗯。。就是这么直接，在 &lt;code&gt;java.lang&lt;/code&gt; 这个包下面，有一个类就叫Class。这个类内部可以记录其他类的成员、接口这些信息，也就是说，Class类是用来&lt;strong&gt;表示其他类的一个类&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议简单总结</title>
    <link href="https://heronking.github.io/archives/ce0e21de.html"/>
    <id>https://heronking.github.io/archives/ce0e21de.html</id>
    <published>2020-03-24T10:04:37.000Z</published>
    <updated>2020-03-25T13:28:23.931Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP，超文本传输协议，是一个客户端和服务端<strong>请求和响应</strong>的<strong>标准TCP</strong>，建立在TCP之上。简单来说，就是用电脑上网，访问web，然后web服务器对电脑的请求作出响应。</p><p>互联网上所有的WWW文件都必须遵守HTTP标准。</p><p><code>http</code>协议在应用层，它是基于传输层的<code>TCP</code>协议。所以http在开始传输前，会首先建立tcp连接，也就是三次握手。</p><a id="more"></a><p><strong>为什么使用TCP协议而不是UDP协议？</strong></p><p>因为一个网页里面有很多数据需要传输，必须保证数据的完整性，不然网页就会出错。</p><h5 id="HTTP的工作流程"><a href="#HTTP的工作流程" class="headerlink" title="HTTP的工作流程"></a>HTTP的工作流程</h5><p>一次HTTP操控叫一个事务</p><blockquote><ul><li>客户端和服务器建立连接（三次握手）</li><li>建立连接后，发送请求</li><li>服务器收到请求，响应信息</li><li>客户端收到回复信息，通过浏览器把信息展示给用户。释放连接（四次挥手）</li></ul></blockquote><p>不过HTTP的连接也不是这么简单的。</p><h5 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h5><p>在<strong>HTTP/1.0</strong>中默认是短连接。每进行一个事务，就建立一次连接，事务结束就释放连接。web页中如果有其他的资源（比如JavaScript文件、图片、css这种），每遇到一个资源，就会重新建立一个HTTP会话。</p><p><strong>HTTP/1.1</strong>中默认是长连接，可以保持连接。使用长连接以后，当一个web页打开完成，客户端和服务器之间的TCP连接不会释放，当客户端再次访问这个服务器的时候，会继续使用这个没有释放的连接。</p><p>在响应头中加入 <code>Connection:keep-alive</code> 就会将HTTP转为长连接。</p><p>长连接让多个HTTP请求可以复用同一个TCP连接，这样可以节省很多连接和断开的消耗。当然，长连接不是永久连接。在header中可以设置一个超时时间，如果该连接在超时时间内没有HTTP请求，那么长连接会被释放。</p><h5 id="HTTP协议响应报文的状态码"><a href="#HTTP协议响应报文的状态码" class="headerlink" title="HTTP协议响应报文的状态码"></a>HTTP协议响应报文的状态码</h5><ul><li>1**，指示信息，表示请求已接收，需要请求继续执行操作</li><li>2**，成功，表示请求已被成功接收并处理</li><li>3**，重定向，让客户端实现URL重定向</li><li>4**，客户端错误，请求包含语法错误或无法完成请求</li><li>5**，服务器错误，服务器在处理请求的过程在发生错误</li></ul><h4 id="在浏览器中输入url地址到返回结果的过程"><a href="#在浏览器中输入url地址到返回结果的过程" class="headerlink" title="在浏览器中输入url地址到返回结果的过程"></a>在浏览器中输入url地址到返回结果的过程</h4><ul><li><strong>DNS解析</strong>，浏览器查找域名所对应的IP地址</li><li><strong>TCP连接</strong>，三次握手</li><li><strong>发送HTTP请求</strong>，客户端发送请求报文</li><li><strong>服务器处理请求并返回HTTP响应报文</strong>，服务器发回响应报文</li><li><strong>浏览器解析渲染页面</strong>，客户端处理数据</li><li><strong>连接释放</strong>，四次挥手</li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul><li><p>HTTP的URL是 <code>http://</code>开头，默认使用80端口；HTTPS的URL由<code>https://</code>开头，默认使用443端口。</p></li><li><p>HTTP协议是基于TCP的，传输内容是明文信息，客户端和服务器的无法验证发送方的身份。</p><p>HTTPS协议是基于SSL/TLS上的HTTP协议，而SSL/TLS是基于TCP的。该协议的所有内容都经过了加密。HTTP的安全性没有HTTPS高，但HTTPS要花费更多的服务器资源，因为需要对报文进行认证。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP，超文本传输协议，是一个客户端和服务端&lt;strong&gt;请求和响应&lt;/strong&gt;的&lt;strong&gt;标准TCP&lt;/strong&gt;，建立在TCP之上。简单来说，就是用电脑上网，访问web，然后web服务器对电脑的请求作出响应。&lt;/p&gt;
&lt;p&gt;互联网上所有的WWW文件都必须遵守HTTP标准。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http&lt;/code&gt;协议在应用层，它是基于传输层的&lt;code&gt;TCP&lt;/code&gt;协议。所以http在开始传输前，会首先建立tcp连接，也就是三次握手。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="计算机网络" scheme="https://heronking.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议简单总结</title>
    <link href="https://heronking.github.io/archives/55ac5dc4.html"/>
    <id>https://heronking.github.io/archives/55ac5dc4.html</id>
    <published>2020-03-23T07:11:17.000Z</published>
    <updated>2020-03-23T12:13:27.892Z</updated>
    
    <content type="html"><![CDATA[<p>TCP协议（Transmission Control Protocol），传输控制协议。属于<strong>传输层</strong>。</p><p>TCP负责检查传输的报文，一旦出现问题就发出信号，要求重新传输，直到所有的数据都安全正确地传输到目的地。</p><p>基于TCP的协议有 <code>HTTP、SMTP、FTP、Telnet、POP3</code>。</p><a id="more"></a><h5 id="TCP协议的应用场景、应用层协议"><a href="#TCP协议的应用场景、应用层协议" class="headerlink" title="TCP协议的应用场景、应用层协议"></a>TCP协议的应用场景、应用层协议</h5><p>要求通信数据可靠无误的时候，就像传输文件、邮件这一类的信息。</p><ul><li>万维网：<code>Http</code> 协议</li><li>邮件传输：<code>SMTP</code>协议</li><li>接受邮件：<code>POP3</code>协议</li><li>文件传输：<code>FTP</code>协议</li><li>远程登录：<code>Telnet</code>协议</li></ul><h5 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h5><p>面向连接、面向字节流、全双工通信、可靠的。（参考自 <a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">简书</a>）</p><p>具体如下：</p><table><thead><tr><th align="center">特点</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">面向连接</td><td align="center">使用TCP传输数据之前，必须先建立连接（三次握手）<br>传输完成后再释放连接（四次挥手）</td></tr><tr><td align="center">全双工通信</td><td align="center">建立TCP连接后，通信的双方都能发送数据</td></tr><tr><td align="center">可靠的</td><td align="center">通过TCP连接的数据不丢失、无差错、不重复、按顺序到达</td></tr><tr><td align="center">面向字节流</td><td align="center">数据以流的形式进行传输<br>流：流入流出进程的字符序列<br>TCP一次传输的报文长度是有限制的，如果超出限制就需要分块，然后依次传输。<br>接收方需要按照顺序接受分块的数据并把他们重新拼接成原样。</td></tr></tbody></table><p>TCP协议也因此<strong>效率较慢</strong>。</p><h5 id="TCP建立连接（三次握手）"><a href="#TCP建立连接（三次握手）" class="headerlink" title="TCP建立连接（三次握手）"></a>TCP建立连接（三次握手）</h5><p>先上图，<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">图源</a></p><img src="/archives/55ac5dc4/1.webp" alt="三次握手" style="zoom:80%;"><p><strong>字段含义</strong>：</p><ul><li>seq：sequence，序列号，就是报文段的序号，等于x就是第x个</li><li><strong>SYN</strong>：synchronize，同步标志，SYN=1、ACK=0表示请求连接；SYN=1、ACK=1表示请求响应</li><li><strong>ACK</strong>：acknowledge，确认标志，TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li><li>ack：确认号，等于x+1就代表正确收到了序号到x的数据</li><li><strong>FIN</strong>：finally，结束标志，等于1表示发送方数据发送完毕，要求释放连接</li></ul><p><strong>连接过程</strong>：</p><ul><li><p>连接前，客户和服务端都处于关闭状态、直到客户端主动打开连接，服务端才会被动打开，然后等待客户端请求。</p></li><li><p><strong>第一次握手</strong>，客户端向服务端发送连接请求（SYN=1）</p></li><li><p><strong>第二次握手</strong>，服务端收到请求，向客户端发送确认（SYN=1，ACK=1）。此时为服务器TCP连接分配资源</p></li><li><p><strong>第三次握手</strong>，客户端收到确认报文段，向服务器发送连接确认（ACK=1）。此时为客户端TCP连接分配资源</p></li><li><p>连接完成</p></li></ul><p>三次握手期间，任何一次未收到回复信息，都会重新发起握手。</p><h6 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h6><p>三次握手的最主要目的就是让双方确认自己和对方的发送与接收都是正常的。</p><p>假设只需要两次握手。</p><p>客户端发起请求连接，但是这个连接因为某种情况而阻塞，服务器并没有收到。客户端超时等待后没有收到服务端的回复，于是再次发起请求连接，这一次，服务器收到请求，发送确认，为客户端分配资源，连接完成。然后客户端和服务器愉快的进行信息交流，直到客户端发送了FIN=1，连接释放。</p><p>然后那个姗姗来迟的请求这时候到了，服务器以为是一个新的请求，于是也发回了一个确认，并为这个请求分配资源。但是客户端早就忘了这个超时的请求，而且此时并没有发送过请求，所以对于这个确认，客户端不会回应。</p><p>于是服务器就一直等待，<strong>形成死锁，造成资源浪费</strong></p><p>当大量的无回应请求出现时，服务器就受到了<strong>SYN洪泛攻击</strong>。</p><p>而连接变成三次握手时，在第三次握手完成前，即客户端发回确认之前，服务器不会为客户端TCP连接分配资源，连接没有完成就不用等待客户端的数据，也就不会死锁了。</p><h5 id="释放连接（四次挥手）"><a href="#释放连接（四次挥手）" class="headerlink" title="释放连接（四次挥手）"></a>释放连接（四次挥手）</h5><p>上图，<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">图源</a></p><img src="/archives/55ac5dc4/2.webp" alt="四次挥手" style="zoom:80%;"><p><strong>连接过程</strong>：</p><ul><li><p>连接前，双方都是已创建状态，直到客户端主动关闭连接。</p></li><li><p><strong>第一次挥手</strong>，客户端向服务器发送连接释放（FIN=1），表示数据发送完毕。</p></li><li><p><strong>第二次挥手</strong>，服务端收到释放请求，向客户端发送释放确认（ACK=1）。<br>此时服务器进入关闭等待，但是可能还有数据要传给客户端。客户端收到确认后，等待服务器的数据传输完成。</p></li><li><p><strong>第三次挥手</strong>，服务器向客户端发送连接释放（FIN=1），表示数据发送完毕。</p></li><li><p><strong>第四次挥手</strong>，客户端收到释放请求，向服务器发送确认（ACK=1）。服务器收到确认后关闭，但客户端进入时间等待（TIME-WAIT），经过<strong>2MSL</strong>（<strong>两个最长报文段寿命</strong>）后依然没有回复，客户端关闭。</p></li><li><p>连接释放。</p></li></ul><h6 id="为什么要等四次挥手？"><a href="#为什么要等四次挥手？" class="headerlink" title="为什么要等四次挥手？"></a>为什么要等四次挥手？</h6><p>目的是，为了保证双方连接释放后，都无法再接受和发送消息。TCP是全双工通信，即使一方释放连接，另一方的连接没有释放，就能继续发送</p><p><strong>为什么要等2MSL？</strong></p><p>为了保证第四次挥手的确认报文能到达服务器，使服务器正常关闭。</p><p>如果客户端发完报文直接关闭，那么当确认报文阻塞或丢失后，服务器等待超时重发连接释放，客户端就收不到，服务器就无法关闭。</p><p>2MSL能保证因为阻塞失效的报文段消失，避免在下次连接中出现。</p><h5 id="TCP协议如何保证可靠传输？"><a href="#TCP协议如何保证可靠传输？" class="headerlink" title="TCP协议如何保证可靠传输？"></a>TCP协议如何保证可靠传输？</h5><ol><li><p>TCP对数据进行合理的<strong>分片和编号</strong>，接收方按照编号对这些数据包排序，组合成原本的数据后再提交给应用层。</p></li><li><p><strong>校验和</strong>，发送数据时，发送端会计算TCP报文段首部和数据的检验和，然后由接收端验证。如果接收端验证校验和有差错，TCP将丢弃该报文。</p></li><li><p>TCP接收端会<strong>丢弃重复的数据</strong>。</p></li><li><p><strong>流量控制</strong>，TCP使用<strong>滑动窗口</strong>实现流量控制。滑动窗口指的是发送方的发送窗口，窗口在报文段上滑动，只有当接收方确认收到数据后，发送窗口才向后滑动。窗口大小根据接受方处理数据的能力变化。</p></li><li><p><strong>拥塞控制</strong>，TCP使用<strong>慢开始、拥塞避免、快重传和快恢复</strong>来进行拥塞控制。</p><ul><li><p><strong>慢开始</strong>：由小（数值为1）到大逐渐增加<strong>拥塞窗口</strong>大小（cwnd，发送窗口），<strong>试探</strong>网络情况。每经过一个轮播（把cwnd中的所有报文都发送了，并收到了最后一个字节的确认），cwnd翻倍。</p></li><li><p><strong>拥塞避免</strong>：使cwnd<strong>按线性缓慢增长</strong>，经过一个轮播，cwnd+1。（<strong>并不能避免拥塞</strong>，只是让拥塞更不容易出现）</p></li><li><p><strong>快重传和快恢复（FFR）</strong>：当接收方发现一个顺序错的数据段，会立即给发送方发一个重复确认（比如先收到了1和2，但是下一个却是收到了4，接下来的5和6也是错的）。当连续收到3个重复确认，发送机就会重发丢失的数据段。不会使cwnd重置为1然后慢开始。</p></li></ul></li><li><p><strong>ARQ协议</strong>：自动重传请求。每发完一组数据就停止，等待对方确认。收到确认再发下一组。</p></li><li><p><strong>超时重传</strong>：TCP发出一段报文后，会启动定时器，如果不能及时收到确认，就会重传这个报文。</p></li></ol><h5 id="TCP协议和UDP协议的区别"><a href="#TCP协议和UDP协议的区别" class="headerlink" title="TCP协议和UDP协议的区别"></a>TCP协议和UDP协议的区别</h5><ul><li>UDP协议传输数据前不需要建立连接，接受方收到UDP报文后，不需要回复确认</li><li>UDP传输的数据不保证可靠性</li><li>UDP的传输效率更高、所需资源更少。</li><li>UDP的传输形式是数据报文段。TCP是字节流，把数据分成很多数据段。</li><li>UDP传输应用于对通信速度要求高的场景，比如即时通讯。</li><li>UDP数据报的首部只有8个字节，TCP有20个。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP协议（Transmission Control Protocol），传输控制协议。属于&lt;strong&gt;传输层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP负责检查传输的报文，一旦出现问题就发出信号，要求重新传输，直到所有的数据都安全正确地传输到目的地。&lt;/p&gt;
&lt;p&gt;基于TCP的协议有 &lt;code&gt;HTTP、SMTP、FTP、Telnet、POP3&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="https://heronking.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL慢查询及优化</title>
    <link href="https://heronking.github.io/archives/708bc100.html"/>
    <id>https://heronking.github.io/archives/708bc100.html</id>
    <published>2020-03-22T08:48:09.000Z</published>
    <updated>2020-03-22T09:26:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中将超过指定时间的sql语句查询成为<strong>慢查询</strong>，可以通过日志来查看记录下的慢查询语句，这个功能需要在配置文件中开启。</p><p>使用咒语：<code>set global slow_query_log = 1</code> ，开启慢查询日志，但只对当前数据库生效，如果MySQL重启则会失效。如果要永久生效，就必须修改配置文件。</p><p>具体怎么配置可以看 <a href="https://www.cnblogs.com/kerrycode/p/5593204.HTML" target="_blank" rel="noopener">这里</a></p><a id="more"></a><h4 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h4><p>先看一下关于创建索引的 <a href="https://heronking.github.io/archives/43a71ae4.html">五大基本原则</a> ，建立一个好的索引是提高效率的重要前提。</p><p><strong>优化的基本步骤</strong>：</p><blockquote><p>0.<strong>先运行看看</strong>是否真的很慢，注意设置SQL_NO_CACHE</p><p>1.<strong>where条件单表查，锁定最小返回记录表</strong>。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p><p>2.<strong>explain查看执行计划</strong>，是否与1预期一致（从锁定记录较少的表开始查询）</p><p>3.<strong>order by limit</strong> 形式的sql语句让排序的表优先查</p><p>4.了解业务方<strong>使用场景</strong></p><p>5.<strong>加索引</strong>时参照建索引的几大原则</p><p>6.观察结果，不符合预期继续从0分析</p></blockquote><p>具体情况还没了解透彻~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL中将超过指定时间的sql语句查询成为&lt;strong&gt;慢查询&lt;/strong&gt;，可以通过日志来查看记录下的慢查询语句，这个功能需要在配置文件中开启。&lt;/p&gt;
&lt;p&gt;使用咒语：&lt;code&gt;set global slow_query_log = 1&lt;/code&gt; ，开启慢查询日志，但只对当前数据库生效，如果MySQL重启则会失效。如果要永久生效，就必须修改配置文件。&lt;/p&gt;
&lt;p&gt;具体怎么配置可以看 &lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/5593204.HTML&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MySQL" scheme="https://heronking.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="https://heronking.github.io/archives/43a71ae4.html"/>
    <id>https://heronking.github.io/archives/43a71ae4.html</id>
    <published>2020-03-21T12:28:07.000Z</published>
    <updated>2020-03-24T06:26:48.192Z</updated>
    
    <content type="html"><![CDATA[<p>数据库中存放着大量的数据，为了提高查找数据的效率，就需要索引。和字典里面的索引目录意义是一样的。</p><p>但数据库要复杂得多，因为往往需要的不仅仅是等值查询，还有范围查询、并集查询、模糊查询。当数据库中存储了非常多的数据，如果是散乱的数据，那么查询基本上都是全表扫描，这样已经谈不上效率不效率了。。</p><p>所以需要对这些数据设计索引，好的索引将大大提升查询效率。</p><a id="more"></a><h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><p>如果有千万级别的数据，可以想到构建一棵<strong>搜索树</strong>，查询效率是O(lgN)。但是数据库把数据放在磁盘上，计算机访问磁盘的成本是访问内存的十万倍左右。普通的机械硬盘，一次磁盘IO可能需要4毫秒以上。</p><p>而操作系统对此有相应的优化，每次磁盘IO都读取一页的数据，一页根据系统一般是4K或者8K（<strong>在MySQL的Innodb引擎中，一页是16K</strong>），读取当前磁盘数据的时，还把相邻数据的地址也读入缓冲区。</p><p>那么索引的数据结构目的就是，把每次查找数据时需要进行的磁盘IO次数尽量减少，最好是常数级。嗯，就是<strong>B+树</strong>。</p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>多路平衡搜索树，所有叶子都在同一层</p><p>上图</p><p><img src="/archives/43a71ae4/1.png" alt="B+树"></p><p>来源 <a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">图源</a>，这里面讲的非常清楚，包括插入和删除。这是一颗4阶B+树，高度是两层，叶子结点存着键值对，并且有指向相邻叶子节点的指针，某种意义上来讲，叶子串起来是一个顺序链表。非叶子节点只存储key，用来指引搜索的方向。</p><p>每一个节点都是一个磁盘块，上图一共5个。他们都存在磁盘中。</p><h6 id="查找方式"><a href="#查找方式" class="headerlink" title="查找方式"></a>查找方式</h6><p>如果这个时候要查找24这个的数据。</p><ul><li>首先加载根节点磁盘块，发生一次IO，通过二分法查到24比23大，55小</li><li>加载23 24 30这个磁盘块，再发生一次IO，二分法查找到24，搜索完成了。</li></ul><p>很明显，这棵树越高，那么磁盘IO的次数就越多。</p><p>一般来说，3层以上的B+树可以表示百万级的数据，磁盘IO只需要三次。大多数Innodb的B+树都是3层，可以存千万条数据</p><h6 id="为什么要把数据放到叶子中？"><a href="#为什么要把数据放到叶子中？" class="headerlink" title="为什么要把数据放到叶子中？"></a>为什么要把数据放到叶子中？</h6><p>为了让树的高度尽量小，那么就要让阶数尽量大，也就是让一个节点中key的个数尽量多</p><p>磁盘块的大小是固定，如果在非叶子节点中存储数据，显然键值对比单纯存key要大，磁盘块中能存放的key数量也因此减少了。树的高度也不可避免的增高。</p><h6 id="为什么B-树比B树更适合索引？"><a href="#为什么B-树比B树更适合索引？" class="headerlink" title="为什么B+树比B树更适合索引？"></a>为什么B+树比B树更适合索引？</h6><ul><li><p>B树的非叶子结点也存储了数据。那么在数据量大的时候，B树会比B+树更高，每多一次IO都消耗很大。</p></li><li><p>B+树的查询效率更加稳定，每次搜索数据都是从根节点走到叶子点。</p></li><li><p>在进行整库搜索时，B+树只需要搜索叶子，而B数需要中序遍历。所以B+树更适合<strong>范围查询</strong>。</p></li></ul><h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>在Innodb引擎中，<strong>聚集索引</strong>是，叶子节点存放着数据，也就是上面的B+树。<strong>一个表中只能有一个聚集索引</strong>，表中的数据会按照聚集索引的顺序存储。检索效率比非聚集索引高。</p><p><strong>非聚集索引</strong>，也是B+树，但是叶子节点还是索引，只不过里面存放着一个指向数据块的指针。也就是说在非聚集索引中，只有索引项按键值的顺序排列，而实际上和索引对应的表中的数据，是按聚集索引排列的。<strong>可以有很多个聚集索引</strong></p><p><strong>举个栗子</strong>：</p><p>新华字典，如果要查”王（wang）“这个字，我们知道他的拼音，就不用去翻目录，因为字典里面排列的顺序是按拼音来的，我们只用翻到”W“开头的那一页，再找W中的“ang”部分就可以发现“王”字。</p><p>所以拼音是新华字典的聚集索引，所有的数据都按照聚集索引排列好。</p><p>但是新华字典还有目录，比如笔画目录。现在要查一个字”王“，如果我们要按照笔画来查，就要先在笔画目录中找到4划的部分，然后里面有很多字，”王“、文“，”木“。在笔画目录中，所有的字都按笔画排好了，但是他们在实际的表中并不是这个顺序，比如王在400页，而文在450页，木在200页。</p><p>所以笔画目录是非聚集索引。</p><p><strong>一般来说</strong>，参考自 <a href="https://zhuanlan.zhihu.com/p/39293940" target="_blank" rel="noopener">知乎</a>：</p><blockquote><p>聚集索引默认是表中的主键索引，如果表中没有显示指定主键，则会选择表中的<strong>第一个不允许为NULL的唯一索引</strong>。如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。</p><p>每张表只有一个聚集索引，因为聚集索引在精确查找和范围查找方面良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增id充当聚集索引）。</p></blockquote><p>在MyISAM中的索引使用的是非聚集索引。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>咒语：</p><ul><li><code>create index xxxx on table(xxxx(length));    //length就是长度</code> </li><li><code>create unique index xxxx on table(xxxx(length));    //唯一索引</code></li><li><code>alter table xxxx add index xxxx(column);   //column就是列名</code></li><li>查看索引：<code>show index from xxx;</code></li></ul><p><strong>创建索引的几大基本原则</strong>：</p><blockquote><p>1.<strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2.<strong>=和in可以乱序</strong>，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><p>3.<strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p><p>4.<strong>索引列不能参与计算，保持列“干净”</strong><br>比如 <code>from_unixtime(create_time) = ’2014-05-29’</code> 就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。<br>所以语句应该写成 <code>create_time = unix_timestamp(’2014-05-29’)</code>。</p><p>5.<strong>尽量的扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库中存放着大量的数据，为了提高查找数据的效率，就需要索引。和字典里面的索引目录意义是一样的。&lt;/p&gt;
&lt;p&gt;但数据库要复杂得多，因为往往需要的不仅仅是等值查询，还有范围查询、并集查询、模糊查询。当数据库中存储了非常多的数据，如果是散乱的数据，那么查询基本上都是全表扫描，这样已经谈不上效率不效率了。。&lt;/p&gt;
&lt;p&gt;所以需要对这些数据设计索引，好的索引将大大提升查询效率。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="https://heronking.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="MySQL" scheme="https://heronking.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="https://heronking.github.io/archives/f91535f.html"/>
    <id>https://heronking.github.io/archives/f91535f.html</id>
    <published>2020-03-21T06:59:01.000Z</published>
    <updated>2020-03-21T09:24:23.849Z</updated>
    
    <content type="html"><![CDATA[<p>事务处理技术包括数据库回复技术和并发控制技术。这个两个机制是DBMS的重要组成部分。</p><h4 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h4><p>事务是用户定义的一个操作序列。这些操作<strong>要么都成功完成、要么都失败</strong>，他们是一个不可分割的工作单位。</p><a id="more"></a><h5 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h5><p>总结为ACID四个特征</p><ul><li>原子性（Atomicity）：事务已经是最小的单位了，不可分割，无论这个事务中有多少个步骤，他们是一个整体，要么全部成功，要求全部失败</li><li>一致性（consistency）：事务必须使数据库从一个正确的状态迁移到另一个争取的状态，也就是说，如果在执行事务之前，库中的数据是合理满足约束的，那么执行事务之后，也应该如此。</li><li>隔离性（isolation）：一个事务的执行不会被其他事务所干扰</li><li>持久性（durability）：每一次事务提交后就保证不会丢失。提交之后对数据库中的数据改变是永久的。</li></ul><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p>银行转账：a 给 b 转账1000，这里就涉及到两条操作</p><p>1.先把a的钱减去1000</p><p>​    <code>update user set money = money - 1000 where name = &#39;a&#39;;</code></p><p>2.再把b的钱加上1000</p><p>​    <code>update user set money = money + 1000 where name = &#39;b&#39;;</code></p><p>如果这两条指令只有a成功，b失败，那a就亏了钱。b成功，a失败，那就是白给1000.</p><p>所以他们是一个事务，要么一起成功，要么一起失败。</p><h4 id="如何控制事务"><a href="#如何控制事务" class="headerlink" title="如何控制事务"></a>如何控制事务</h4><p>MySQL中是默认设置下，事务是自动提交（@autocommit）。</p><p>作用是，当我们执行了一个sql语句，按下回车就能出现结果，这就是自动提交，而且不能回滚了。</p><p><strong>什么是回滚？</strong><br>即 rollback 命令，执行之后<strong>撤销未提交</strong>的sql命令。</p><p><strong>通过手动开启自己的事务</strong>。</p><p>可以先关闭自动提交：<code>set autocommit = 0;</code> </p><p>执行sql语句以后，我们对表和数据的修改效果会出现在临时的表中，对于不满意的修改可以使用 <code>rollback</code> 回滚操作。修改完成后，使用咒语 <code>commit</code> 提交修改，<strong>提交之后不可撤销</strong>。</p><p>或者使用咒语 <code>begin;</code> 或 <code>start transaction;</code>，即使自动提交没有关闭也能开启一个不会自动提交的事务。</p><p>在事务中的操作可以通过 <code>rollback</code> 回滚。修改完成需要 <code>commit</code> 提交，<strong>提交之后事务结束</strong>。</p><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li><p><strong>read uncommitted</strong>：读未提交，可能会出现<strong>脏读</strong>问题</p><p><strong>栗子</strong>：老板发工资了（开启事务1，并update），张三去查了自己的余额发现是5000（事务2，select），张三很开心（commit事务2）。<br>但张三的实际工资应该是2000，于是老板回滚操作，并发2000（rollback，然后update），最后核实无误再提交（commit事务1）.</p><p>并发的事务中，一个事务可能查询另外的事务的未提交数据。这就是<strong>脏读</strong></p></li><li><p><strong>read committed</strong>：读已提交，可能会出现<strong>不可重复读</strong>问题</p><p><strong>栗子</strong>：张三准备用刚发的2000块工资去吃一块新疆切糕，查一下钱是2000（事务1，select），然后准备把钱拿出来。<br>这时候张三的女朋友用他的工资卡买了一个2000块的包包（事务2，update），并在张三之前提交了该事务（commit事务2）。<br>这个时候取钱却发现余额不足，于是张三选择再看一遍工资卡（select），此时余额变成了0，张三不停地 select，但每一次余额都是0，于是他只能悲哀地commit。</p><p>并发的事务访问同一个数据，事务1先查询，事务2马上更新数据并提交，事务1再次查询读取数据时，该数据已经改变。</p><p>这个级别虽然可以<strong>避免脏读</strong>，但是可能会出现<strong>不可重复读</strong>的问题。</p></li><li><p><strong>repeatable read</strong>：重复读，可能会出现<strong>幻读</strong>问题</p><p>该隔离级别可以避免不可重复读。当事务1开始查询数据，在事务1提交之间，事务1无论何时查询到的数据都是一样的。这个和上面差不多，会出现新的问题。</p><p><strong>栗子</strong>：张三换了级别准备再去取钱，先查一下（事务1开始，select）。这个时候张三的老婆以迅雷不及掩耳盗铃之势转走工资卡里的钱并马上提交（事务2，update，commit）。<br>于是张三取钱再次失败了，余额不足，他再查了一遍（select），余额明明和刚开始时一样的，并且不管select多少次，余额都不变，但是钱却取不出来。张三感觉，这应该是梦。</p><p>这就是<strong>幻读</strong>。</p><p><strong>需要注意的是</strong>，MySQL的innoDB引擎默认是RR级别，并且已经通过MVCC自动解决了幻读问题，所以已经模拟不出来了。幻读和不可重复读十分类似，都是因为非线程安全。</p></li><li><p><strong>serializable</strong>：序列化</p><p>这是最高的级别，可以避免所有的问题。因为这个级别下，数据是线程安全的。</p><p>所谓序列化，就是给数据加同步锁。这个锁是针对<strong>写操作</strong>的。</p><p><strong>栗子</strong>：这次张三换了最高级别去取钱，同样先查一下（事务1，select）。张三的老婆发动故技重施，先转走所有的钱（事务2，update），但是却发现，银行柜台机卡住了，转账中这个界面一直在转。<br>然后张三取出钱，最后提交了（事务1，commit）。假设<strong>没有超时</strong>，这时，张三老婆那边就显示，转账失败，余额不足。如果超时了，那边就显示，超时请重试。</p><p>当一个事务1访问数据时，其他并发事务对该数据的<strong>写操作</strong>会进入等待阻塞（序列化），在事务1后面排队。直到事务1提交，下一个事务如果没有超时，才能对数据进行操作。</p><p>这个级别性能十分低，花费资源多，一般很少使用。</p></li></ul><h5 id="查看和修改系统的隔离级别"><a href="#查看和修改系统的隔离级别" class="headerlink" title="查看和修改系统的隔离级别"></a>查看和修改系统的隔离级别</h5><p>MySQL 8.0以上查询，使用咒语：</p><p><code>select @@global.transaction_isolation;  //系统级别</code><br><code>select @@transaction_isolation;  //会话级别</code></p><p>一般两个都是  <strong>REPEATABLE-READ</strong></p><p>修改：</p><p><code>set global transaction isolation level xxxxx;     //修改系统级别</code><br><code>set transaction isolation level xxxxx;     //修改会话级别</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事务处理技术包括数据库回复技术和并发控制技术。这个两个机制是DBMS的重要组成部分。&lt;/p&gt;
&lt;h4 id=&quot;事务的基本概念&quot;&gt;&lt;a href=&quot;#事务的基本概念&quot; class=&quot;headerlink&quot; title=&quot;事务的基本概念&quot;&gt;&lt;/a&gt;事务的基本概念&lt;/h4&gt;&lt;p&gt;事务是用户定义的一个操作序列。这些操作&lt;strong&gt;要么都成功完成、要么都失败&lt;/strong&gt;，他们是一个不可分割的工作单位。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MySQL" scheme="https://heronking.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询记录</title>
    <link href="https://heronking.github.io/archives/50092300.html"/>
    <id>https://heronking.github.io/archives/50092300.html</id>
    <published>2020-03-20T09:23:54.000Z</published>
    <updated>2020-03-20T14:45:28.975Z</updated>
    
    <content type="html"><![CDATA[<p>一些查询语句，防止忘记。</p><a id="more"></a><h5 id="查最高成绩"><a href="#查最高成绩" class="headerlink" title="查最高成绩"></a>查最高成绩</h5><p>运用子查询，但是如果有多个最高成绩只能差一个</p><p><code>select sno, cno from score where degree = (select max(degree) from score);</code></p><p>或者</p><p><code>select sno,cno,degree from score order by degree desc limit 0,1;</code></p><p>先逆序然后选取</p><p>limit的参数0表示从第0个开始，1表示选取一个。有几个最高就选几个。</p><p>结果都是</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 103 | 3-105 |     92 |<br>+—–+——-+——–+</p><h5 id="查平均成绩"><a href="#查平均成绩" class="headerlink" title="查平均成绩"></a>查平均成绩</h5><p>这是查一门课：</p><p><code>select avg(degree) from score where cno = &#39;3-105&#39;;</code></p><p>结果</p><p>+————-+<br>| avg(degree) |<br>+————-+<br>|     85.3333 |<br>+————-+</p><p>查每一门课程：</p><p><code>select cno,avg(degree) from score group by cno;</code></p><p>先分组再算</p><p>结果</p><p>+——-+————-+<br>| cno   | avg(degree) |<br>+——-+————-+<br>| 3-105 |     85.3333 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+——-+————-+</p><h5 id="查询成绩表中至少有2名学生选修以3开头的课程的平均分数。"><a href="#查询成绩表中至少有2名学生选修以3开头的课程的平均分数。" class="headerlink" title="查询成绩表中至少有2名学生选修以3开头的课程的平均分数。"></a>查询成绩表中至少有2名学生选修以3开头的课程的平均分数。</h5><p><code>select cno,avg(degree),count(*) from score group by cno having count(cno) &gt;= 2 and cno like(&#39;3-%&#39;);</code></p><p>‘%’就相当于正则里面的‘*’，having和where类似，但having只能跟在group by后面，where只能跟在from后面。</p><p>结果</p><p>+——-+————-+———-+<br>| cno   | avg(degree) | count(*) |<br>+——-+————-+———-+<br>| 3-105 |     85.3333 |        3 |<br>| 3-245 |     76.3333 |        3 |<br>+——-+————-+———-+</p><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,cno,degree </span><br><span class="line"><span class="keyword">from</span> student,score </span><br><span class="line"><span class="keyword">where</span> student.sno = score.sno <span class="keyword">order</span> <span class="keyword">by</span> cno;</span><br></pre></td></tr></table></figure><p>根据两个表中的相同数据连接</p><p>结果</p><p>+———–+——-+——–+<br>| sname     | cno   | degree |<br>+———–+——-+——–+<br>| 王丽      | 3-105 |     92 |<br>| kuangming | 3-105 |     88 |<br>| lijun     | 3-105 |     76 |<br>| 王丽      | 3-245 |     86 |<br>| kuangming | 3-245 |     75 |<br>| lijun     | 3-245 |     68 |<br>| 王丽      | 6-166 |     85 |<br>| kuangming | 6-166 |     79 |<br>| lijun     | 6-166 |     81 |<br>+———–+——-+——–+</p><h5 id="查询和某人同年出生"><a href="#查询和某人同年出生" class="headerlink" title="查询和某人同年出生"></a>查询和某人同年出生</h5><p>假设某人是学号为108和101的两个人</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(sbirth) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">year</span>(sbirth) </span><br><span class="line">    <span class="keyword">from</span> student </span><br><span class="line">    <span class="keyword">where</span> sno <span class="keyword">in</span> (<span class="number">108</span>, <span class="number">101</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过子查询先选取年份</p><p>结果</p><p>+—–+———–+——+————+——-+<br>| sno | sname     | ssex | sbirth     | class |<br>+—–+———–+——+————+——-+<br>| 101 | 曾华      | 男   | 1977-09-01 | 95033 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     |<br>| 108 | znehua    | man  | 1997-09-01 | 1     |<br>+—–+———–+——+————+——-+</p><h5 id="多表嵌套子查询"><a href="#多表嵌套子查询" class="headerlink" title="多表嵌套子查询"></a>多表嵌套子查询</h5><p>选某个课程选修人数大于2人的教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">where</span> tno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> tno <span class="keyword">from</span> course</span><br><span class="line">    <span class="keyword">where</span> cno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> cno <span class="keyword">from</span> score</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> cno</span><br><span class="line">        <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>先找到选同一门课人数大于2的课程号</li><li>再从这些找到这些课程号的教师编号</li><li>通过教师编号查询教师信息</li></ul><p>结果</p><p>+—–+——–+——+————+———–+—————–+<br>| tno | tname  | tsex | birth      | prof      | depart          |<br>+—–+——–+——+————+———–+—————–+<br>| 804 | 李诚   | 男   | 1958-12-02 | 副教授    | 计算机系        |<br>| 825 | 王萍   | 女   | 1972-05-05 | 助教      | 计算机系        |<br>| 856 | 张旭   | 男   | 1969-03-12 | 讲师      | 电子工程系      |<br>+—–+——–+——+————+———–+—————–+</p><h5 id="union和not-in的使用"><a href="#union和not-in的使用" class="headerlink" title="union和not in的使用"></a>union和not in的使用</h5><p>查询两个系内职称不同的教师信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher </span><br><span class="line"><span class="keyword">where</span> depart = <span class="string">'电子工程系'</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">prof <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> prof <span class="keyword">from</span> teacher</span><br><span class="line">    <span class="keyword">where</span> depart = <span class="string">'计算机系'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher </span><br><span class="line"><span class="keyword">where</span> depart = <span class="string">'计算机系'</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">prof <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> prof <span class="keyword">from</span> teacher</span><br><span class="line">    <span class="keyword">where</span> depart = <span class="string">'电子工程系'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先分别把对方系内没有的职称找出来，然后把两个系用 union 连接</p><p>结果</p><p>+—–+——–+——+————+———–+—————–+<br>| tno | tname  | tsex | birth      | prof      | depart          |<br>+—–+——–+——+————+———–+—————–+<br>| 856 | 张旭   | 男   | 1969-03-12 | 讲师      | 电子工程系      |<br>| 804 | 李诚   | 男   | 1958-12-02 | 副教授    | 计算机系        |<br>+—–+——–+——+————+———–+—————–+</p><p>如果用分组聚合来找不同，需要注意的是，<strong>对group by进行查询只能查group by指定的聚合列、聚合函数、常量</strong>。不过，可以通过更改sql模式来查询。现在不能查询非聚合列的模式是<strong>ONLY_FULL_GROUP_BY</strong>。</p><h5 id="子查询any"><a href="#子查询any" class="headerlink" title="子查询any"></a>子查询any</h5><p>查询3-105课程的成绩中大于3-245课程成绩中的至少一个的成绩。（鬼才语文）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">where</span> cno = <span class="string">'3-105'</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">degree &gt; <span class="keyword">any</span> (</span><br><span class="line"><span class="keyword">select</span> degree <span class="keyword">from</span> score</span><br><span class="line">    <span class="keyword">where</span> cno = <span class="string">'3-245'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> degree <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>any的意思是其中任意一个。如果要查询比其中<strong>所有</strong>都要大的，那只需要<strong>把any改成all</strong>。</p><p>结果</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 103 | 3-105 |     92 |<br>| 105 | 3-105 |     88 |<br>| 109 | 3-105 |     76 |<br>+—–+——-+——–+</p><h5 id="查询成绩小于该课程平均成绩的分数信息"><a href="#查询成绩小于该课程平均成绩的分数信息" class="headerlink" title="查询成绩小于该课程平均成绩的分数信息"></a>查询成绩小于该课程平均成绩的分数信息</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score a</span><br><span class="line">  <span class="keyword">where</span> degree &lt; (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">avg</span>(degree) <span class="keyword">from</span> score b</span><br><span class="line">    <span class="keyword">where</span> a.cno = b.cno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结果</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 105 | 3-245 |     75 |<br>| 105 | 6-166 |     79 |<br>| 109 | 3-105 |     76 |<br>| 109 | 3-245 |     68 |<br>| 109 | 6-166 |     81 |<br>+—–+——-+——–+</p><h5 id="查询不包含某个字符"><a href="#查询不包含某个字符" class="headerlink" title="查询不包含某个字符"></a>查询不包含某个字符</h5><p><code>select * from student where sname not like &#39;王%&#39; and sname not like &#39;wang%&#39;;</code></p><p>用not like就行</p><p>结果</p><p>+—–+———–+——+————+——-+<br>| sno | sname     | ssex | sbirth     | class |<br>+—–+———–+——+————+——-+<br>| 101 | 曾华      | 男   | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男   | 1975-10-02 | 95031 |<br>| 104 | 李军      | 男   | 1976-02-20 | 95033 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     |<br>| 106 | 陆军      | 男   | 1974-06-03 | 95031 |<br>| 108 | znehua    | man  | 1997-09-01 | 1     |<br>| 109 | lijun     | man  | 1996-08-11 | 3     |<br>+—–+———–+——+————+——-+</p><h5 id="查询年龄，运用now"><a href="#查询年龄，运用now" class="headerlink" title="查询年龄，运用now"></a>查询年龄，运用now</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname, <span class="keyword">year</span>(<span class="keyword">now</span>())-<span class="keyword">year</span>(sbirth) <span class="keyword">as</span> age</span><br><span class="line"><span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>结果</p><p>+———–+——+<br>| sname     | age  |<br>+———–+——+<br>| 曾华      |   43 |<br>| 匡明      |   45 |<br>| 王丽      |   44 |<br>| 李军      |   44 |<br>| kuangming |   23 |<br>| 陆军      |   46 |<br>| wangli    |   22 |<br>| znehua    |   23 |<br>| lijun     |   24 |<br>+———–+——+</p><h5 id="子查询嵌套"><a href="#子查询嵌套" class="headerlink" title="子查询嵌套"></a>子查询嵌套</h5><p>查询选修计算机导论的女同学成绩表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">where</span> cno = (</span><br><span class="line"><span class="keyword">select</span> cno <span class="keyword">from</span> course</span><br><span class="line">    <span class="keyword">where</span> cname = <span class="string">'计算机导论'</span></span><br><span class="line">) <span class="keyword">and</span> sno <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> ssex = <span class="string">'女'</span> <span class="keyword">or</span> ssex = <span class="string">'woman'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结果</p><p>+—–+——-+——–+<br>| sno | cno   | degree |<br>+—–+——-+——–+<br>| 103 | 3-105 |     92 |<br>+—–+——-+——–+</p><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><p><strong>内联查询</strong> <code>inner join....on</code> ：</p><p><code>select * from student a inner join score b on a.sno = b.sno;</code> </p><p>结果</p><p>+—–+———–+——+————+——-+—–+——-+——–+<br>| sno | sname     | ssex | sbirth     | class | sno | cno   | degree |<br>+—–+———–+——+————+——-+—–+——-+——–+<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 103 | 3-105 |     92 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 103 | 3-245 |     86 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 103 | 6-166 |     85 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 105 | 3-105 |     88 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 105 | 3-245 |     75 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 105 | 6-166 |     79 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 109 | 3-105 |     76 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 109 | 3-245 |     68 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 109 | 6-166 |     81 |<br>+—–+———–+——+————+——-+—–+——-+——–+</p><p>就是按照id把两个表放一起。需要两个表里都有相同的id</p><p><strong>左外连接</strong> <code>left join.....on</code>：</p><p><code>select * from student a left join score b on a.sno = b.sno;</code></p><p>结果</p><p>+—–+———–+——-+————+——-+——+——-+——–+<br>| sno | sname     | ssex  | sbirth     | class | sno  | cno   | degree |<br>+—–+———–+——-+————+——-+——+——-+——–+<br>| 101 | 曾华      | 男    | 1977-09-01 | 95033 | NULL | NULL  |   NULL |<br>| 102 | 匡明      | 男    | 1975-10-02 | 95031 | NULL | NULL  |   NULL |<br>| 103 | 王丽      | 女    | 1976-01-23 | 95033 | 103  | 3-105 |     92 |<br>| 103 | 王丽      | 女    | 1976-01-23 | 95033 | 103  | 3-245 |     86 |<br>| 103 | 王丽      | 女    | 1976-01-23 | 95033 | 103  | 6-166 |     85 |<br>| 104 | 李军      | 男    | 1976-02-20 | 95033 | NULL | NULL  |   NULL |<br>| 105 | kuangming | man   | 1997-10-01 | 2     | 105  | 3-105 |     88 |<br>| 105 | kuangming | man   | 1997-10-01 | 2     | 105  | 3-245 |     75 |<br>| 105 | kuangming | man   | 1997-10-01 | 2     | 105  | 6-166 |     79 |<br>| 106 | 陆军      | 男    | 1974-06-03 | 95031 | NULL | NULL  |   NULL |<br>| 107 | wangli    | woman | 1998-05-01 | 3     | NULL | NULL  |   NULL |<br>| 108 | znehua    | man   | 1997-09-01 | 1     | NULL | NULL  |   NULL |<br>| 109 | lijun     | man   | 1996-08-11 | 3     | 109  | 3-105 |     76 |<br>| 109 | lijun     | man   | 1996-08-11 | 3     | 109  | 3-245 |     68 |<br>| 109 | lijun     | man   | 1996-08-11 | 3     | 109  | 6-166 |     81 |<br>+—–+———–+——-+————+——-+——+——-+——–+</p><p>左边的表有和右边表相同id就列出来，没有就标为null。</p><p><strong>右外连接</strong> <code>right join....on</code>：与上面相反。</p><p>*<em>MySQL不支持全连接 <code>full join</code> *</em>：就是把左右连接和在一起。</p><p><strong>自然连接</strong> <code>natural join</code>：</p><p><code>select * from student natural join score;</code></p><p>结果</p><p>+—–+———–+——+————+——-+——-+——–+<br>| sno | sname     | ssex | sbirth     | class | cno   | degree |<br>+—–+———–+——+————+——-+——-+——–+<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 3-105 |     92 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 3-245 |     86 |<br>| 103 | 王丽      | 女   | 1976-01-23 | 95033 | 6-166 |     85 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 3-105 |     88 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 3-245 |     75 |<br>| 105 | kuangming | man  | 1997-10-01 | 2     | 6-166 |     79 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 3-105 |     76 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 3-245 |     68 |<br>| 109 | lijun     | man  | 1996-08-11 | 3     | 6-166 |     81 |<br>+—–+———–+——+————+——-+——-+——–+</p><p>不需要指定连接条件，MySQL会自动使用表内相同的字段把两个表连接在一起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些查询语句，防止忘记。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="MySQL" scheme="https://heronking.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库的三大范式</title>
    <link href="https://heronking.github.io/archives/e7b99fed.html"/>
    <id>https://heronking.github.io/archives/e7b99fed.html</id>
    <published>2020-03-20T07:27:43.000Z</published>
    <updated>2020-03-20T08:34:34.379Z</updated>
    
    <content type="html"><![CDATA[<p>在进行数据库设计的时候应该满足三大范式。书上写的晕头转向，记一下理解。</p><p>三大范式具体如下：</p><ul><li>第一范式 1NF，确保每一列的<strong>原子性</strong>。</li><li>第二范式 2NF，在1NF的基础上，确保表中的<strong>每列都和主键相关</strong>，而且是完全依赖。</li><li>第三范式 3NF，在2NF的基础上，确保<strong>每列数据都和主键直接相关，不能是间接相关</strong>，即消除传递依赖。</li></ul><a id="more"></a><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>先上个表</p><table><thead><tr><th>ID</th><th>Name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>深圳市福田区xxxx</td></tr><tr><td>2</td><td>李四</td><td>长沙市岳麓区xxxx</td></tr></tbody></table><p>这个表不满足，因为地址还能拆分成城市和地区。可拆分，那就不是原子的。</p><p>虽然第一范式要求是原子的，但有些时候也不是一定要拆。在你需要对城市进行区分的时候，才需要拆，如果不需要通过地址进行分类，反而能提升性能。</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>满足第一范式，其他每一列都<strong>必须完全依赖于</strong>主键，啥叫完全依赖？当主键是联合主键的时候，其他列和这个联合主键中的每一个都有关系。</p><p>比如说：</p><p>这个表的主键是（订单id和顾客id）</p><table><thead><tr><th align="center">订单id</th><th align="center">商品id</th><th align="center">商品信息</th><th align="center">顾客</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">抱枕</td><td align="center">张三</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">被子</td><td align="center">李四</td><td align="center">6</td></tr></tbody></table><p>显然，商品信息只和商品id有关，和订单还有顾客没啥关系，那么这就违反了2NF。</p><p>要满足2NF，那就需要拆表：</p><p>这是个订单表，主键是订单id，其他id是外键</p><table><thead><tr><th align="center">订单id</th><th align="center">商品id</th><th align="center">顾客id</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">6</td></tr></tbody></table><p>商品表</p><table><thead><tr><th align="center">商品id</th><th align="center">商品信息</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">抱枕</td></tr><tr><td align="center">2</td><td align="center">被子</td></tr></tbody></table><p>顾客信息</p><table><thead><tr><th align="center">顾客id</th><th align="center">顾客名</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td></tr><tr><td align="center">2</td><td align="center">李四</td></tr></tbody></table><p>拆完之后他们就各自满足2NF了。</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>满足第二范式，不存在传递依赖，啥叫传递依赖？</p><p>a = b，b = c，a = c，这个叫传递，= 换成依赖，那就是传递依赖。</p><p>比如说上面那个订单信息表再加一列</p><table><thead><tr><th align="center">订单id</th><th align="center">商品id</th><th align="center">顾客id</th><th align="center">性别</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">男</td><td align="center">5</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">女</td><td align="center">6</td></tr></tbody></table><p>很明显订单id和性别没什么关系，性别是依赖于顾客的，根据传递依赖我们得出订性别依赖于订单id，那么这就不满足3NF。</p><p>这里很好解决，把性别放到顾客信息就行了。</p><table><thead><tr><th align="center">顾客id</th><th align="center">顾客名</th><th align="center">性别</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">张三</td><td align="center">男</td></tr><tr><td align="center">2</td><td align="center">李四</td><td align="center">女</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行数据库设计的时候应该满足三大范式。书上写的晕头转向，记一下理解。&lt;/p&gt;
&lt;p&gt;三大范式具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式 1NF，确保每一列的&lt;strong&gt;原子性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第二范式 2NF，在1NF的基础上，确保表中的&lt;strong&gt;每列都和主键相关&lt;/strong&gt;，而且是完全依赖。&lt;/li&gt;
&lt;li&gt;第三范式 3NF，在2NF的基础上，确保&lt;strong&gt;每列数据都和主键直接相关，不能是间接相关&lt;/strong&gt;，即消除传递依赖。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
      <category term="MySQL" scheme="https://heronking.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装</title>
    <link href="https://heronking.github.io/archives/8b39915a.html"/>
    <id>https://heronking.github.io/archives/8b39915a.html</id>
    <published>2020-03-19T10:42:58.000Z</published>
    <updated>2020-03-19T11:05:11.547Z</updated>
    
    <content type="html"><![CDATA[<p>装mysql的时候遇到很多坑。</p><p>弄的是免安装版的，所以需要各种奇奇怪怪的配置。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>从官网 <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载</a> </p><a id="more"></a><p><img src="/archives/8b39915a/1.png" alt></p><p>下这个版本就行了。但是速度巨慢，基本上没有个一下午是弄不完的</p><p>我是从 <a href="http://mirrors.sohu.com/mysql/MySQL-8.0/" target="_blank" rel="noopener">镜像</a> 下载的</p><p><img src="/archives/8b39915a/2.png" alt></p><p>速度起飞。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>把下好的压缩包解压到好了以后，在目录下新建一个文件 <code>my.ini</code> ，这就是你的配置文件。内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port=3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\\MySQL</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=D:\\MySQL\\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 允许连接失败的次数。</span><br><span class="line">max_connect_errors=10</span><br><span class="line"># 服务端使用的字符集默认为utf8mb4</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"># 默认使用“mysql_native_password”插件认证</span><br><span class="line">#mysql_native_password</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure><p><strong>注意，data文件夹不能自己建立</strong>。</p><h4 id="安装、初始化、启动服务"><a href="#安装、初始化、启动服务" class="headerlink" title="安装、初始化、启动服务"></a>安装、初始化、启动服务</h4><p>首先用管理员身份打开cmd</p><p>然后通过cd 进入MySQL的bin目录</p><p>然后输入咒语：<code>mysqld --install</code>，出现 <code>Service successfully installed</code></p><p>下一个咒语： <code>mysqld --initialize --console</code> ，然后就会出现一堆代码，那里面有一段是 <code>password is generated for root@localhost：xxxxxx</code>。运用我们的小学二年级英语，就知道了这个东西是密码。</p><p><strong>记住密码</strong></p><p>接下来使用咒语：<code>net start mysql</code>，启动mysql</p><p>先别关闭。</p><h4 id="登录并修改密码"><a href="#登录并修改密码" class="headerlink" title="登录并修改密码"></a>登录并修改密码</h4><p>接着上面使用咒语：<code>mysql -u root -p</code>，回车以后就提示输入Enter password</p><p>把刚刚的密码输入进去回车，这样就可以开始用MySQL。</p><p>改密码写SQL就行了： <code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;密码&#39;;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装mysql的时候遇到很多坑。&lt;/p&gt;
&lt;p&gt;弄的是免安装版的，所以需要各种奇奇怪怪的配置。&lt;/p&gt;
&lt;h4 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h4&gt;&lt;p&gt;从官网 &lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://heronking.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>java集合简单总结</title>
    <link href="https://heronking.github.io/archives/f5e78ffc.html"/>
    <id>https://heronking.github.io/archives/f5e78ffc.html</id>
    <published>2020-03-18T13:37:17.000Z</published>
    <updated>2020-03-19T06:38:43.914Z</updated>
    
    <content type="html"><![CDATA[<p>java中的集合框架主要分为两类：Collection 和 Map</p><ul><li>Collection 是单列集合，Map是双列</li><li>Collection中的Set要求集合元素唯一，Map中的键值为一，值没有限制</li></ul><a id="more"></a><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><ul><li><p>List</p><ul><li>ArrayList：Object数组</li><li>LinkedList：双向链表（JDK1.7取消了循环链表）</li><li>Vector：已过时，被ArrayList取代</li></ul></li><li><p>Set</p><ul><li>HashSet：无序且元素唯一，使用哈希法存储元素，底层是HashMap。</li><li>LinkedHashSet：继承于HashSet，但底层是LinkedHashMap。存取<strong>有顺序</strong>，元素唯一，即存进的顺序和取出来的顺序是一样的。</li><li>TreeSet：就是一棵红黑树（自平衡的排序二叉树），存取无序，但自动排序，这是红黑树的特点。</li></ul></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li>HashMap：<a href="https://heronking.github.io/archives/166dc6bc.html">详情</a> ，使用数组 + 链表/红黑树 的哈希表结构，存储的是Entry键值对。</li><li>LinkedHashMap：继承于HashMap，底层结构在HashMap的基础上<strong>增加了一条双向链表</strong>，用来保持键值对的插入顺序，所以它存取有序。</li><li>TreeMap：红黑树，可以通过实现Comparator接口来指定排序方法。</li><li>Hashtable：与HashMap功能类似，数组 + 链表组成，不能存有null的键值。线程安全，但不推荐使用。多线程使用ConcurrentHashMap</li></ul><h4 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h4><p>根据集合特点来选。</p><p>如果需要用到键值，那自然就选Map，根据具体情况来选某一个Map，比如需要排序就用TreeMap，不需要排序就用HashMap，需要保证线程安全就用ConcurrentHashMap。</p><p>如果只需要用来存放元素，那就用Collection，需要元素唯一就用Set，不需要就用List。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中的集合框架主要分为两类：Collection 和 Map&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection 是单列集合，Map是双列&lt;/li&gt;
&lt;li&gt;Collection中的Set要求集合元素唯一，Map中的键值为一，值没有限制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="面试" scheme="https://heronking.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>简述HashMap的工作原理</title>
    <link href="https://heronking.github.io/archives/166dc6bc.html"/>
    <id>https://heronking.github.io/archives/166dc6bc.html</id>
    <published>2020-03-18T09:31:07.000Z</published>
    <updated>2020-03-24T06:13:44.695Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是java中运用特别多的数据结构，写一点面试的时候可能会用到的知识。</p><p>JDK1.8以后 hashMap 的底层经过了优化，在1.8以前是使用<strong>挂链式</strong>解决 <a href="https://heronking.github.io/archives/1293cfc0.html">哈希冲突</a> 。优化之后，当链表的长度大于一个阈值（默认是8），那么存储哈希冲突的链表会转为红黑树，优化查找时间为O(lgn)。</p><p>为什么是8呢？</p><a id="more"></a><p>如果这个阈值设置太小，相同的哈希数量频繁达到阈值，那么底层就会频繁的在链表和红黑树之间转换。哈希冲突的概率满足泊松分布，同样的哈希值达到8的概率非常小。</p><p>HashMap底层用到的哈希表结构是这样的（<a href="https://www.jianshu.com/p/54d5c2b58125" target="_blank" rel="noopener">图源</a>）：</p><img src="/archives/166dc6bc/1.png" alt="哈希表" style="zoom:80%;"><p>可以看到，如果存储的数据没有哈希冲突，那么这个哈希表就是一个根据哈希值来存储的散列数组。</p><h4 id="HashMap的工作原理是什么？"><a href="#HashMap的工作原理是什么？" class="headerlink" title="HashMap的工作原理是什么？"></a>HashMap的工作原理是什么？</h4><p>我们使用 <code>put(key, value)</code> 的方式存储对象到HashMap中，使用 <code>get(key)</code> 方法从HashMap中获得对象。</p><p>当存数据的时候，HashMap首先会对键值使用哈希函数 ，此时函数返回的值就是哈希表中的一个bucket位置（图中存放Entry的就是bucket，上面有6个）来存储Entry对象。</p><p>Entry对象是一个静态内部类，里面有属性key、value 和 next，对于每一个需要存储的键值对，HashMap都把他们放到Entry里面。</p><h4 id="当要存储的两个对象哈希码值相同会发生什么？"><a href="#当要存储的两个对象哈希码值相同会发生什么？" class="headerlink" title="当要存储的两个对象哈希码值相同会发生什么？"></a>当要存储的两个对象哈希码值相同会发生什么？</h4><p>也就是哈希冲突发生了。</p><p>由于哈希码值相同，那么他们会找到同一个bucket，然后对两个Entry的调用<code>equals()</code>方法。</p><p>如果返回的是false，那么就将这两个对象存放的Entry组成一个链表，然后把链表的头节点放在bucket中，如上图一样。此时 <code>put()返回的是null</code>，因为插入的是一个新的值。</p><p>如果 <code>equals()</code>方法返回true，说明HashMap中已经存在真正一样的key，此时原来键值对中value，会被替换成新插入的value，<code>put()</code> 方法返回的是原来键值对中的value。</p><p>比如HashMap中已经存在<code>&lt;1, &quot;aaa&quot;&gt;</code> ，那么执行 <code>put(1, &quot;bbb&quot;)</code>，HashMap中就变成了 <code>&lt;1, &quot;bbb&quot;&gt;</code> ，然后put方法返回的是 “aaa”。</p><h4 id="怎么取出哈希码相同的某一个值对象？"><a href="#怎么取出哈希码相同的某一个值对象？" class="headerlink" title="怎么取出哈希码相同的某一个值对象？"></a>怎么取出哈希码相同的某一个值对象？</h4><p>直接查找存储在bucket中的链表，使用 <code>key.equals(Entry.key)</code> 来判断是否找到，最后返回对应的value对象即可。如果链表特别长，那么查找的效率会非常低，因此优化为红黑树，提高效率。</p><h4 id="HashMap的大小超过了负载因子怎么办？"><a href="#HashMap的大小超过了负载因子怎么办？" class="headerlink" title="HashMap的大小超过了负载因子怎么办？"></a>HashMap的大小超过了负载因子怎么办？</h4><p>hashMap默认的负载因子(load factor)是0.75，也就是说，如果数据<strong>填满了75%的bucket数组</strong>，那么就是超过了负载因子。</p><p>HashMap就会创建一个新的 <strong>2 * 原capacity (默认16，可自己定义)</strong> 大小的bucket数组，并将原数组中的所有对象都放到这个新的里面。</p><p>这个过程叫做rehash，原数组的每一个对象需要<strong>重新hash</strong>才能放到新的bucket数组中。因为HashMap计算哈希码的方法是： <code>hashCode &amp; (n - 1)（n是新的bucket数组长度）</code>。 </p><h4 id="多线程下重新调整HashMap的大小有什么问题？"><a href="#多线程下重新调整HashMap的大小有什么问题？" class="headerlink" title="多线程下重新调整HashMap的大小有什么问题？"></a>多线程下重新调整HashMap的大小有什么问题？</h4><p>HashMap是非线程安全的，在多线程下会产生资源竞争。在<strong>JDK1.7</strong>中因为rehash而迁移的链表元素会全部倒置，如果此时条件竞争发生，那么就会出现循环链表，查询循环链表会形成死锁。</p><p>但JDK1.8已经解决了这个，因为链表迁移不会再倒置了。</p><p>但还是不建议在多线程下使用。</p><h4 id="为什么wrapper类更适合作为键值？"><a href="#为什么wrapper类更适合作为键值？" class="headerlink" title="为什么wrapper类更适合作为键值？"></a>为什么wrapper类更适合作为键值？</h4><p>因为String、Integer这些wrapper类是用final修饰的，是不可变的，而且这些类中已经重写过了 <code>equals() 和 hashCode()</code> 方法。</p><p>不变这个条件是必要的，因为hashMap需要计算key的hashcode，那就必须防止键值改变，如果键值在 <code>put()</code> 完成以后，再用 <code>get()</code> 调用的时候返回的是不同的hashcode，那么就找不到这个key对应的value了。</p><p>正确的重写那两个方法也是必要的。一个好的hashCode()方法也能提高HashMap的性能，减少哈希冲突。</p><h4 id="自定义对象是否可以作为键值？"><a href="#自定义对象是否可以作为键值？" class="headerlink" title="自定义对象是否可以作为键值？"></a>自定义对象是否可以作为键值？</h4><p>只要该对象满足上面所说的wrapper类的条件就能作为键值。</p><p><strong>ConcurrentHashMap 和 Hashtable 区别</strong></p><p>ConcurrentHashMap的同步性能比Hashtable更好，因为它只对map的一部分上锁，属于分段锁，对整个bucket数组都进行了分割，每一把锁都只锁一部分数据。这样可以避免多线程出现锁竞争，提高并发访问率。</p><p>因此Hashtable提供更强的线程安全性，用的是一把锁，竞争越激烈效率越低。</p><p>一般来说都是用ConcurrentHashMap来替代Hashtable，Hashtable已经基本被淘汰了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap是java中运用特别多的数据结构，写一点面试的时候可能会用到的知识。&lt;/p&gt;
&lt;p&gt;JDK1.8以后 hashMap 的底层经过了优化，在1.8以前是使用&lt;strong&gt;挂链式&lt;/strong&gt;解决 &lt;a href=&quot;https://heronking.github.io/archives/1293cfc0.html&quot;&gt;哈希冲突&lt;/a&gt; 。优化之后，当链表的长度大于一个阈值（默认是8），那么存储哈希冲突的链表会转为红黑树，优化查找时间为O(lgn)。&lt;/p&gt;
&lt;p&gt;为什么是8呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="面试" scheme="https://heronking.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>总结final关键字</title>
    <link href="https://heronking.github.io/archives/ef816ce.html"/>
    <id>https://heronking.github.io/archives/ef816ce.html</id>
    <published>2020-03-18T06:27:28.000Z</published>
    <updated>2020-03-18T06:52:29.285Z</updated>
    
    <content type="html"><![CDATA[<p>final是Java中的一个关键字，用来修饰变量、方法或者类，和static用法差不多。final可以理解成“无法改变”的意思。</p><p>但是，<strong>final不能用来修饰抽象类</strong>，这是因为final有这些特性：</p><a id="more"></a><ul><li>被final修饰的类<strong>不能被继承</strong>，在final类中的方法默认为final。所以它不能用来修饰抽象类，因为抽象类设计出来就是为了被继承，<a href="https://heronking.github.io/archives/e6551811.html">前面</a> 已经提到过。</li><li>被final修饰的方法不能被子类重写，但是可以被继承过去。<br><strong>注意一下，private方法也是不能被子类重写的，所以private类型的方法默认是final的。</strong></li><li>对于一个final变量，如果是基本数据类型，那么它的数值在初始化之后就不能更改；<br>如果修饰的是一个引用，那么在初始化之后不能再指向其他的对象。<strong>如果引用内部的数据不是final，那么是可以进行修改的，只是引用的指向不能修改</strong><br>其实final变量也就是<strong>常量</strong>。</li><li>final不能用于修饰构造方法。</li></ul><h4 id="那么为什么要使用final呢？"><a href="#那么为什么要使用final呢？" class="headerlink" title="那么为什么要使用final呢？"></a>那么为什么要使用final呢？</h4><ol><li>锁定方法，防止子类重写。</li><li><strong>高效</strong>，final方法是内嵌调用机制。（但现在已经不需要了，因为private类型的方法默认都是final）</li></ol><h4 id="final和static的区别"><a href="#final和static的区别" class="headerlink" title="final和static的区别"></a>final和static的区别</h4><ul><li>final把数据修饰为常量，无法修改</li><li>static把数据修饰为静态，放入方法区</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;final是Java中的一个关键字，用来修饰变量、方法或者类，和static用法差不多。final可以理解成“无法改变”的意思。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;final不能用来修饰抽象类&lt;/strong&gt;，这是因为final有这些特性：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>线程、进程、程序的区别和联系</title>
    <link href="https://heronking.github.io/archives/d680fc0.html"/>
    <id>https://heronking.github.io/archives/d680fc0.html</id>
    <published>2020-03-17T14:03:25.000Z</published>
    <updated>2020-03-17T15:12:54.585Z</updated>
    
    <content type="html"><![CDATA[<p>线程是比进程更小的<strong>执行单位</strong>。进程是<strong>线程的容器</strong>，是程序的<strong>基本执行实体</strong>。</p><h4 id="什么是程序？"><a href="#什么是程序？" class="headerlink" title="什么是程序？"></a>什么是程序？</h4><blockquote><p>程序是含有指令和数据的文件，被存储在磁盘上，其本身是一堆静态的代码。</p></blockquote><a id="more"></a><p>程序是作为一种软件资料长期存在的，说白了就是个文件。只要不动它，它就只能在那什么也做不了。从某种意义上讲，程序是永久的。</p><p><strong>程序是不能单独执行的</strong>，只有把程序加载到内存中，系统为它分配资源后才能执行，而这种执行中的程序就是进程。</p><h4 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h4><blockquote><p>进程是程序的一次执行过程，是系统运行程序的基本单位，所以进程是一个动态的概念。</p></blockquote><p>一个进程就是一个执行中的程序，它占用着系统的资源，比如CPU时间、内存、文件、I/O设备的使用权等等。</p><p>进程是有生命周期的，当进程终止以后，就需要系统再次分配资源执行程序才能创建新的进程。</p><p>程序可以对应多个进程，而且这些进程之间是相互独立的。</p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><blockquote><p>进程是系统分配资源和调度的基本单位，而线程是CPU调度和分派的基本单位。</p></blockquote><p>一个进程中可以包含若干个线程，这些线程之间是共享资源的。所以线程是进程的更小划分。</p><p>进程在执行过程中拥有自己独立的系统资源和内存。而线程在运行时基本不拥有系统资源，只是暂用一些计数器、寄存器和栈。</p><p>系统产生线程或者在各个线程之间切换时，负担和消耗比进程要小得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程是比进程更小的&lt;strong&gt;执行单位&lt;/strong&gt;。进程是&lt;strong&gt;线程的容器&lt;/strong&gt;，是程序的&lt;strong&gt;基本执行实体&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;什么是程序？&quot;&gt;&lt;a href=&quot;#什么是程序？&quot; class=&quot;headerlink&quot; title=&quot;什么是程序？&quot;&gt;&lt;/a&gt;什么是程序？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;程序是含有指令和数据的文件，被存储在磁盘上，其本身是一堆静态的代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
      <category term="线程" scheme="https://heronking.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的基本状态与生命周期</title>
    <link href="https://heronking.github.io/archives/70ca885c.html"/>
    <id>https://heronking.github.io/archives/70ca885c.html</id>
    <published>2020-03-17T09:22:03.000Z</published>
    <updated>2020-03-25T07:36:01.204Z</updated>
    
    <content type="html"><![CDATA[<p>开门见山！参考自 <a href="https://blog.csdn.net/pange1991/article/details/53860651?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">博客</a> 。</p><p>线程的基本状态有6种，java线程在生命周期中的某一个指定时刻只可能处于一种状态。</p><p>先看看有哪6中状态</p><a id="more"></a><blockquote><table><thead><tr><th align="center">状态名</th><th>说   明</th></tr></thead><tbody><tr><td align="center">初始态（New）</td><td>线程被构建，但还没有调用 <code>start()</code> 方法</td></tr><tr><td align="center">运行态（Runnable）</td><td>java线程将就绪态（ready）和运行中（running）两种状态统称为运行态。<br>线程对象创建并调用 <code>start()</code> 方法之后，该线程就位于可运行线程池中，等待系统调度。这个状态叫就绪态（ready）。<br>就绪态的线程在获得 CPU时间片之后就会开始执行，此时线程就处于运行中（running）</td></tr><tr><td align="center">阻塞态（Blocked）</td><td>线程阻塞于锁</td></tr><tr><td align="center">等待态（waiting）</td><td>进入该状态的线程表示当前线程需要等待其他线程做出一些特定动作（比如通知或中断）</td></tr><tr><td align="center">超时等待（Time_Waiting）</td><td>该状态不同于等待态，它可以在指定的时间后自行返回。</td></tr><tr><td align="center">终止态（Terminated）</td><td>线程已经执行完毕</td></tr></tbody></table></blockquote><p><strong>源码在Thread类的State中。</strong></p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>看图说话，这张图（<a href="https://www.cnblogs.com/aspirant/p/8900276.html" target="_blank" rel="noopener">来源</a>）详细的记录了Java线程之间的切换：</p><p><img src="/archives/70ca885c/1.jpg" alt="线程之间的切换"></p><p>还有简单版（<a href="https://blog.csdn.net/huakai_sun/article/details/78287931" target="_blank" rel="noopener">来源</a>）的：</p><p><img src="/archives/70ca885c/2.jpg" alt="线程切换"></p><h4 id="初始态"><a href="#初始态" class="headerlink" title="初始态"></a>初始态</h4><p>实现Runnable接口或者继承Thread可以得到线程类，使用new实例化以后，线程就进入了初始态。此时的线程情况是：</p><ul><li>JVM为该线程分配内存，初始化成员变量</li><li>线程对象没有表现出线程的动态特征，程序不会执行线程的内容。</li></ul><h4 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h4><p>就绪态的线程不会立即执行，而是在<strong>可运行线程池</strong>中<strong>等待CPU调度，为其分配CPU时间片</strong>以后才会开始执行，进入运行中状态。</p><p>让线程进入就绪态的情况，图上已经有标识了</p><ul><li>实例对象调用 <code>start()</code> 方法，线程进入就绪态。</li><li>各种各样的阻塞（sleep、join、用户I/O）完成之后、锁池中的线程拿到对象锁（还是因为阻塞），线程会回到就绪态</li><li>当前线程的时间片用完了、或者调用 <code>yield()</code> <strong>让出CPU调度</strong>，线程回到就绪态。这里是从运行态回到就绪态</li></ul><h4 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h4><p>线程调度从可运行线程池（处于就绪态的线程们）中选择一个线程调用并分配资源，那么该线程就会进入运行态。<strong>这是线程进入运行态的唯一途经</strong>。</p><p>此时，自动调用该线程对象的 <code>run()</code> 方法，而 <code>run()</code>方法内定义了这个线程功能。</p><p>若此时调用 <code>yeild()</code> 方法，线程会<strong>让出CPU</strong>，重新回到就绪态，也可能会发生刚回去又马上分配到资源再次执行的情况。</p><h4 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h4><p>一个正在运行的线程在特殊情况下，会让出自己的资源并暂时中止，这就是阻塞。</p><p>阻塞态可以分为三种：</p><ul><li><p><strong>等待阻塞</strong>，线程调用 <code>wait()</code> 方法，该线程<strong>释放CPU也释放锁</strong>并进入等待队列中等待被再次唤醒（其他线程调用 <code>notify()</code> 方法随机唤醒一个，调用 <code>notifyAll()</code> 方法唤醒全部，或者线程结束后自动唤醒）。唤醒后会放入锁池队列中和其他线程竞争同步锁。<strong>这个状态就是java线程里的等待态</strong>。</p></li><li><p><strong>同步阻塞</strong>，线程遇到同步锁，但锁被其他线程占用，该线程进入锁池转为同步阻塞，与其他线程竞争同步锁。当再次获取到锁，线程进入就绪态。</p></li><li><p><strong>其他阻塞</strong>，有几种情况：</p><ul><li><p>线程调用 <code>sleep()</code> 方法，该线程<strong>释放CPU但不释放锁</strong>，线程会抱着锁开始睡觉，等待sleep时间到或者调用了 <code>interrupt()</code> 方法才会结束。<br><strong>这里在java中也被称为超时等待态</strong>，相当于在 <strong>等待态</strong> 的基础上增加了超时限制，一般通过 sleep(long s) 和 wait(long s) 让程序进入超时等待。当时间到了之后，线程进入就绪态。</p></li><li><p>当前线程调用另一个线程的 <code>join()</code> 方法，比如 <code>t2.join()</code>，那么当前线程 t 进入阻塞，直到 t2 结束。</p></li><li><p>等待用户的I/O操作，当前线程进入阻塞。</p></li></ul></li></ul><p><strong>再次注意，阻塞结束后，线程会回到就绪态。</strong></p><h4 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h4><p>线程调用 <code>stop()</code> 方法、<code>destroy()</code> 方法、遇到异常终止、线程正常执行完也就是 <code>run()</code> 方法执行结束后，线程死亡。</p><p><strong>处于终止态的线程不再具备运行能力</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开门见山！参考自 &lt;a href=&quot;https://blog.csdn.net/pange1991/article/details/53860651?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;线程的基本状态有6种，java线程在生命周期中的某一个指定时刻只可能处于一种状态。&lt;/p&gt;
&lt;p&gt;先看看有哪6中状态&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
      <category term="线程" scheme="https://heronking.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>equals和hashCode</title>
    <link href="https://heronking.github.io/archives/333b0902.html"/>
    <id>https://heronking.github.io/archives/333b0902.html</id>
    <published>2020-03-17T07:19:10.000Z</published>
    <updated>2020-03-18T10:11:40.107Z</updated>
    
    <content type="html"><![CDATA[<p>在java中有一个基础方法 <code>hashCode()</code>，和 <code>equals() toString()</code> 一样，是 Object类 里面的方法，嗯，Object是所有类的老父亲。</p><p>从某种严格的意义上讲，每一个java类都需要重写这三个方法。不过一般不这么干，用不到就不重写。</p><a id="more"></a><h4 id="关于hashCode的介绍"><a href="#关于hashCode的介绍" class="headerlink" title="关于hashCode的介绍"></a>关于hashCode的介绍</h4><p>其实hashCode()就是 <a href="https://heronking.github.io/archives/1293cfc0.html">哈希表</a> 的散列函数，它的返回值就是hash码，那个传说中的key值，嗯，是个int型的。</p><p>它的存在就是为了哈希表服务的。</p><p>java中有两种<strong>集合</strong>，一类是List，一类是Set。我们在小学二年级的时候就学过集合的概念，不过在计算机语言中，集合是一种数据结构。</p><p>这里说一下HashSet这个集合，它是Set的一个子类，它也比较接近数学中的集合，存储在它里面的元素<strong>无序且不可重复的</strong>。为什么是无序的呢？因为它是根据 <code>hashCode()</code> 返回的散列码来存储的。</p><p><strong>那么HashSet如何检查重复？</strong></p><p>在向HashSet中使用 <code>add()</code> 添加一个对象元素时，HashSet会先得到该元素调用hashCode()之后返回的散列码key，然后根据这个key值判断该元素应该存储的位置，<strong>若该位置已经有元素对象</strong>，那么就与已经添加元素的hashCode值作比较。</p><p>如果不同，那么HashSet就会认为该元素没有重复。</p><p>如果相同（<strong>注意这里只是hashCode的值相同</strong>），就要调用 <code>equals()</code> 方法来检查这两个对象是不是真的一样。最后如果返回了true，那么HashSet就认为两个元素重复，add操作就会返回false，加入失败。</p><p>这就是  <code>hashCode()</code> 的用途。</p><h4 id="重写-equals-的时候，也要重写hashCode"><a href="#重写-equals-的时候，也要重写hashCode" class="headerlink" title="重写 equals 的时候，也要重写hashCode"></a>重写 equals 的时候，也要重写hashCode</h4><p>通过上面集合的栗子可以看到，集合判断元素是否重复，需要同时用到equals和hashCode，如果其中一个被重写了，另一个必须做出相应的重写，不然就会出错。</p><p>这里有相关规定：</p><blockquote><ul><li>如果两个对象相等，则 hashCode 一定也是相同的</li><li>如果两个对象相等，那么对两个对象分别调用 equals 和 hashcode方法都会返回true</li><li>两个对象有相同的 hashcode值，但他们的不一定是相等的。</li><li>equals 方法被重写，则 hashcode也必须被重写</li><li>hashCode() 的默认行为是<strong>对堆上的对象产生独特的散列码值</strong>。如果没有重写 hashCode()，则该类的<strong>两个实例对象无论如何都不会相等</strong>，即使这两个对象指向相同的数据。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java中有一个基础方法 &lt;code&gt;hashCode()&lt;/code&gt;，和 &lt;code&gt;equals() toString()&lt;/code&gt; 一样，是 Object类 里面的方法，嗯，Object是所有类的老父亲。&lt;/p&gt;
&lt;p&gt;从某种严格的意义上讲，每一个java类都需要重写这三个方法。不过一般不这么干，用不到就不重写。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="面试" scheme="https://heronking.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>理解哈希表</title>
    <link href="https://heronking.github.io/archives/1293cfc0.html"/>
    <id>https://heronking.github.io/archives/1293cfc0.html</id>
    <published>2020-03-17T06:13:48.000Z</published>
    <updated>2020-03-17T15:07:04.235Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表是一个用途十分广泛的数据结构，也叫散列表。散列的意思就是，散装排列嘛，把一些要存储的数据散列地放到表里面。</p><a id="more"></a><p>为什么要有哈希表呢？</p><p>先看看我们常用的数据结构</p><p><strong>普通数组</strong>：对数据的寻址简单且效率高，但插入和删除效率低。<br><strong>链表</strong>：对数据的插入和删除效率高，但寻址的效率低，平衡树的查找也需要O(lgn)。</p><p>而哈希表就是查询、插入、删除一般都只需要O(1)复杂度的数据结构。</p><p>对比其他数据结构，有张图：</p><img src="/archives/1293cfc0/1.png" alt="数据结构复杂度" style="zoom:75%;"><h4 id="哈希表的实现原理"><a href="#哈希表的实现原理" class="headerlink" title="哈希表的实现原理"></a>哈希表的实现原理</h4><p>哈希表的核心机制是<strong>散列函数</strong>。我们在小学二年级的时候就学过，什么叫函数。<br>函数是一种映射，即<strong>一对一</strong>，或者<strong>多对一</strong>的关系。不能一对多！</p><p>当然，这里的散列函数期望的是<strong>一对一</strong>的关系。在存储某一个数据的时候，我们把数据放到散列函数里面映射出一个key值，这个key值叫做哈希码，也就是散列码，而我们就是通过散列码来确定该数据在哈希表中的索引位置。</p><p>反之，如果知道了key值，就能直接检索到与之对应的数据。</p><p>哈希表也就实现了高效率存取。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>现在需要存储一组数据：14 16 5 58 42。</p><p>要哈希表来存储他们，首先呢，随便确定一个散列函数，<code>f(x) = x % 5</code> ，随便用的。</p><p>对于第一个数，<code>f(14) = 14 % 5 = 4</code> ，所以第一个数就是 <code>hash(4) = 14</code><br>第二个数，<code>f(16) = 16 % 5 = 1</code> ，那么 <code>hash(1) = 16</code><br>接下来，<code>hash(0)= 5    hash(3) = 58   hash(2) = 42</code> </p><p>存完了以后，接下来就是查找数据。这里是无序的，如果只是数组，那就得用for搜5次。</p><p>比如说我要在表内查一下16这个数据有没有，那么只需要看 <code>hash(16 % 5) == 16</code>，如果是true那自然就是有。</p><h4 id="哈希表的问题"><a href="#哈希表的问题" class="headerlink" title="哈希表的问题"></a>哈希表的问题</h4><p>前面说过，散列函数是<strong>期望</strong>一对一的关系，但是如果数据很多，再好的散列函数也可能出现多对一的情况，这个就是hash冲突。</p><p>解决hash冲突的方式一般有开放地址法、再哈希法、建立缓冲区</p><ul><li>挂链式，把产生冲突的hash地址指向一个单链表，这个链表存的就是具有相同key值的数据。而hash表中只存这个链表的头指针</li><li>缓冲区，把哈希表分为基本表和溢出表，和基本表发生hash冲突的数据放到溢出表中。</li><li>开放地址，对于冲突的key值，根据这个key在哈希表里面再找一个不冲突的地址</li><li>再哈希法，多整几个散列函数，多算几遍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表是一个用途十分广泛的数据结构，也叫散列表。散列的意思就是，散装排列嘛，把一些要存储的数据散列地放到表里面。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="https://heronking.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数据结构" scheme="https://heronking.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>==和equals</title>
    <link href="https://heronking.github.io/archives/cefdebd3.html"/>
    <id>https://heronking.github.io/archives/cefdebd3.html</id>
    <published>2020-03-16T13:42:58.000Z</published>
    <updated>2020-03-16T14:53:30.858Z</updated>
    
    <content type="html"><![CDATA[<p>在java中 <code>==</code> 和 <code>equals()</code> 是有一点点区别滴</p><p>直接上用法</p><a id="more"></a><h4 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a><code>==</code> 运算符</h4><p>这个运算符在使用时有两种情况：</p><ul><li>在两个基本数据类之间作比较时，比较的是两个数据的值是否相等。</li><li>两个对象之间作比较时，它判断是两个对象的地址是否相等。</li></ul><h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a><code>equals()</code> 方法</h4><p>同样也分两种情况：</p><ul><li><p>当该类没有重写 <code>equals()</code> 方法。那么该方法用于两个对象之间的比较时，等价于使用 <code>==</code>。</p></li><li><p>类重写了 <code>equals()</code> 方法。一般来说，都重写为用来比较两个对象的内容是否相等的形式，若相等则返回为 <code>true</code> ，也就认为这两个对象相等。</p><p>当然，具体的实现方法都由自己决定。</p></li></ul><p><strong>举个栗子说明一下</strong></p><p>先声明一下变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个基本数据类型</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">float</span> d = (<span class="keyword">float</span>) <span class="number">15.0</span>;</span><br><span class="line"><span class="comment">// 两个String对象，他们内容相同</span></span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);<span class="comment">//这个字符串会放到常量池中。在堆中new一个了String类，并在栈内创建了一个引用</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);<span class="comment">//在常量池中找到了"aaa"。在堆中new一个String类，并在栈内创建了一个新的引用。</span></span><br><span class="line"><span class="comment">// 两个字符串常量</span></span><br><span class="line">String aa = <span class="string">"aaa"</span>;<span class="comment">//在常量池中查找到</span></span><br><span class="line">String bb = <span class="string">"aaa"</span>;<span class="comment">//在常量池中查找到</span></span><br></pre></td></tr></table></figure><p>再用 <code>==</code> 和 <code>equals()</code> 方法对比一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aa == bb) &#123;</span><br><span class="line">System.out.println(<span class="string">"aa == bb"</span>);</span><br><span class="line">&#125;<span class="comment">//输出了aa == bb</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">System.out.println(<span class="string">"a == b"</span>);</span><br><span class="line">&#125;<span class="comment">//没有输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">System.out.println(<span class="string">"a equals b"</span>);</span><br><span class="line">&#125;<span class="comment">//输出了a equals b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">System.out.println(<span class="string">"c == d"</span>);</span><br><span class="line">&#125;<span class="comment">//输出了c == d</span></span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><p><strong>为什么没有输出 <code>a == b</code> 而输出了 <code>a equals b</code> 呢？</strong></p><p>这里需要说明一下，在 String 类中的 <code>equals()</code> 方法是<strong>已经被重写过的</strong>，所以这里使用的 <code>equals()</code> 其实比较的是内容。<br>所以输出 a equals b 也就不奇怪了，因为他们的内容相同。</p><p>而 a == b 这里的 <code>==</code> 比较的是两者的地址。</p><p>引用存放在 <a href="https://heronking.github.io/archives/eae4d02d.html">栈区</a> ，a 是一个引用，指向的是对象<code>new String(&quot;aaa&quot;)</code>，b 是另一个引用，指向的是一个新的对象 <code>new String(&quot;aaa&quot;)</code>。他们是<strong>两个不同的对象</strong></p><p><strong>那么为什么输出了 aa == bb呢？</strong></p><p>因为当我们创建一个String类时，JVM会从常量池中查找是否存在内容和要创建的值相同的对象，如果存在的话，就会返回这个对象的引用。如果不存在，那么就会在常量池中创建一个新的String。</p><p> <code>String aa</code> 在常量池中找了”aaa”，那么 aa = “aaa”的引用<br><code>String bb</code> 也找到了，所以 bb = “aaa” 的引用</p><p>所以他们俩的地址是相等的。</p><p><strong>那么在内存中到底是啥样的呢？</strong></p><p>常量池：字符串”aaa”，只有这一个<br>堆：属于 a 的 new String(“aaa”)，属于 b 的 new String(“aaa”)</p><p>嗯。。基本数据类型就不写了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java中 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 是有一点点区别滴&lt;/p&gt;
&lt;p&gt;直接上用法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="面试" scheme="https://heronking.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM的栈、堆、方法区</title>
    <link href="https://heronking.github.io/archives/eae4d02d.html"/>
    <id>https://heronking.github.io/archives/eae4d02d.html</id>
    <published>2020-03-16T08:00:18.000Z</published>
    <updated>2020-03-17T15:09:21.135Z</updated>
    
    <content type="html"><![CDATA[<p>java中的存储方式也是比较重要滴。</p><p>先看看JVM的数据区是咋样的</p><a id="more"></a><img src="/archives/eae4d02d/1.png" alt="JVM运行时的数据区" style="zoom:30%;"><h4 id="栈，也就是JVM栈"><a href="#栈，也就是JVM栈" class="headerlink" title="栈，也就是JVM栈"></a>栈，也就是JVM栈</h4><p>简单的记录，因为我也没怎么懂。</p><ul><li><p>栈中保存所有在方法中定义的基础数据类型，还有对象的引用，比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;<span class="comment">//在方法中</span></span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//基本数据类型</span></span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'b'</span>;<span class="comment">//基本数据类型</span></span><br><span class="line">      Object o;<span class="comment">//对象的引用</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>什么是对象的引用？</strong></p><p>就是指向对象的地址或者说对象的变量名，形象一点就是系着气球的绳子<br>一个引用可以指向<strong>1个或者0个</strong>对象，就像绳子只能系着一个气球，也可以不系。<br>当然，多个不同的引用可以指向同一个对象，多根绳子系着同一个气球也是可以的</p></li></ul><p><strong>总的来说</strong></p><ul><li><p>栈中的数据是私有的，其他的栈不可以访问。每个线程都会享有一个栈区，可以开辟很多个。</p></li><li><p>在方法中定义的基本数据类型和对象的引用都在该方法的栈中分配内存</p></li><li><p>当程序执行完某一个代码块后，也就是其中的栈内变量退出作用域，java会自动释放这些变量的内存，给别的地方用。</p></li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是用来存放<strong>new创建的对象</strong>的，且堆内存是多个线程共享的，随着JVM的启动而创建。JVM自动垃圾回收就是作用在堆内存上，用不到的对象会自动回收释放堆内存。</p><ul><li>堆中存储的全部是对象（<strong>数组</strong>也是对象）</li><li>JVM只有一个堆，被所有线程共享，堆中只存放对象本身，对象本身包括它的实例变量。</li><li>JVM会在程序运行时动态地给对象分配内存，用完会自动回收</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区和堆一样，也是线程共享的。</p><p>方法区里面存储的是，类的信息，包括类名、方法、字段(也就是类的成员)，还存储静态成员、常量、编译后的代码、接口。</p><p>方法区中有一个部分是<strong>运行时常量池</strong>，在类和接口被加载到 JVM 后，对应的运行时常量池就会被创建。</p><p>常量池主要存放的是<strong>字面量</strong>和<strong>符号引用量</strong>。</p><p>字面量就是那些常量，比如文本化的字符串，final常量值这些。<br>符号引用量包括三种类型的常量：类和接口的全限定名、字段名称和描述符、方法名称和描述符。嗯，我还不懂，这是编译层面的概念。</p><p>就只写这些吧~ 其他的看情况再研究。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中的存储方式也是比较重要滴。&lt;/p&gt;
&lt;p&gt;先看看JVM的数据区是咋样的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java静态</title>
    <link href="https://heronking.github.io/archives/b2323594.html"/>
    <id>https://heronking.github.io/archives/b2323594.html</id>
    <published>2020-03-16T06:34:16.000Z</published>
    <updated>2020-03-18T07:28:12.376Z</updated>
    
    <content type="html"><![CDATA[<p>在java的静态也就是 <code>static</code> 关键字，用来修饰成员变量和成员方法，比如 <code>static int a;</code> ，也可以用来做静态代码块，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，在java中一般没有全局变量这种概念，因为变量啥的都是放在类里面的。</p><a id="more"></a><p>先写一下java中的创建对象时的初始化顺序，也就是在 <code>new Object()</code> 的时候，顺序如下：</p><ul><li>父类静态成员和静态代码块，从上到下依次执行。</li><li>子类静态成员和静态代码块，从上到下依次执行。</li><li>父类实例成员和实例代码块，从上到下依次执行。也就是父类的非静态区域，这里是每创建一个实例对象时都会执行一次。</li><li>父类构造方法。构造方法是一个类<strong>最后</strong>才执行的，也是每创建一个实例对象都会执行一次。</li><li>子类实例成员和实例代码块，从上到下依次执行。每次都执行</li><li>子类构造方法。每次都执行</li></ul><p><strong>需要注意的是</strong>，<strong>静态成员和代码块只会执行一次</strong>，而且是在类被加载到内存的时候就会执行，不需要等到创建实例对象。所以静态成员是直接属于类的，而不是属于实例对象。</p><h3 id="写一下关于静态变量和非静态成员的存储位置"><a href="#写一下关于静态变量和非静态成员的存储位置" class="headerlink" title="写一下关于静态变量和非静态成员的存储位置"></a>写一下关于静态变量和非静态成员的存储位置</h3><p>静态成员是属于类本身的，<strong>被这个类所有的实例对象共享</strong>，在这个类被JVM加载的时候，静态成员会跟着类一起被加载到一个叫做 <a href="https://heronking.github.io/archives/eae4d02d.html">方法区</a> 的位置，分配内存，不会被自动回收，会一直占用内存直到程序结束，JVM关闭。</p><p>非静态成员属于实例化对象，在对象被实例化的时候，也就是 <strong>new</strong> 的时候，JVM会从堆中动态分配内存给对象。非静态成员必须通过对象来访问，并随着对象一起被JVM回收。</p><h3 id="关于静态方法和实例方法的区别"><a href="#关于静态方法和实例方法的区别" class="headerlink" title="关于静态方法和实例方法的区别"></a>关于静态方法和实例方法的区别</h3><ul><li><p>在本类外调用静态方法时，可以使用 <code>类名.静态方法名()  或者  对象名.方法名()</code> 的方式。而实例方法只能使用后者的方式。</p></li><li><p>在静态方法中，只能访问本类的静态成员，不允许访问实例成员，否则报错。实例方法没有限制</p><p><strong>为什么会报错？</strong></p><p>上面已经提到过，在非静态成员还没有被实例化的之前，静态方法已经加载完成了，访问非静态成员，也就是一个堆内存中还不存在的东西，自然就出错。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java的静态也就是 &lt;code&gt;static&lt;/code&gt; 关键字，用来修饰成员变量和成员方法，比如 &lt;code&gt;static int a;&lt;/code&gt; ，也可以用来做静态代码块，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;不过，在java中一般没有全局变量这种概念，因为变量啥的都是放在类里面的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>接口和抽象类</title>
    <link href="https://heronking.github.io/archives/e6551811.html"/>
    <id>https://heronking.github.io/archives/e6551811.html</id>
    <published>2020-03-15T10:42:23.000Z</published>
    <updated>2020-03-16T05:47:54.980Z</updated>
    
    <content type="html"><![CDATA[<p>这里记一些接口和抽象类的异同点<br>这两者本身的设计目的就是不一样的！我是直接从用法上理解的，设计完了用来干嘛，理解了也就知道了两者的异同。</p><p><strong>先理解一下什么是抽象类和接口</strong></p><a id="more"></a><h5 id="对于抽象类"><a href="#对于抽象类" class="headerlink" title="对于抽象类"></a>对于抽象类</h5><p>​    个人理解抽象类设计出来是为了，<strong>代码复用</strong>。</p><p>​    当我们设计类的时候，发现有很多不同的类都需要用到某些<strong>相同的方法</strong>，而且其中<strong>一部分</strong>的方法实现的都是一样的。</p><p>​    比如，先创建 <code>class 橘猫</code> 、<code>class 黑猫</code> 、<code>class 蓝猫</code><br>​    它们都要用到同样的方法 ：<br>​    <code>void eat(){}//吃东西</code>、 <code>void meow(){}//喵喵叫</code>、<code>void like()//喜欢做的事</code>  </p><p>​    这个时候我们可以想到，设计一个大类 <code>class 猫</code>，然后把这些相同的方法都放到里面。但是呢这些看似相同的方法，对于有一些方法，不同的类可能会有不同的实现。</p><p>​    比如，橘猫的 <code>like()</code> 实现是喜欢吃东西，而黑猫的实现是喜欢做警察，蓝猫的实现是喜欢三千问。<br>​    这样一来，如果把<code>like()</code> 也放进 <code>猫</code> 里面，那么就没办法实现不同的猫各自喜欢不同的事了。</p><p>​    所以，就引入了抽象类 <code>(abstract class)</code> 的概念。</p><p>​    我们把 <code>void like()</code> 写成抽象方法，于是 <code>class 猫</code> 就成了一个抽象类（因为有抽象方法的类必然是一个抽象类）</p><p>​    而那些大家都会用到的相同方法，比如 <code>eat() 和 meow()</code> ，我们只需要继承 <code>猫</code> 就行了，而不需要重复的写，这样就实现了<strong>代码复用</strong> 。<br>​    那些我们想要在不同类各自不同实现的方法，就只需要把该抽象类中的抽象方法具体实现就可以了！</p><p>​    当然，继承一个抽象类以后，里面所有的方法都要强制实现，所以抽象方法不能是<code>static 和 private</code>。<br>​    同时，这也引入了一个限制，如果有我不需要实现的方法，该咋办呢？</p><p>​    所以，就有了<strong>接口</strong>。</p><h5 id="对于接口"><a href="#对于接口" class="headerlink" title="对于接口"></a>对于接口</h5><p>​    同样是个人理解，接口的作用是，<strong>对类的一种延申和扩展</strong>。</p><p>​    如果给不同的类添加相同的接口，那么这些不同的类就拥有了看似相同的方法，但是，接口不会限制这些方法的实现方式。</p><p>​    举个栗子！我们要给猫咪设计一个技能 <code>void 抓老鼠()</code><br>​    显然，不是每一只猫咪都会抓老鼠（🤣）</p><p>​    所以我们不能把 <code>抓老鼠()</code> 放到 <code>class 猫</code> 里面，而且不同的猫咪<code>抓老鼠()</code> 的方式可能不一样。</p><p>​    比如说黑猫使用枪抓老鼠，蓝猫抓老鼠会首先和老鼠做朋友。</p><p>​    于是，接口  <code>interface</code> 就出现了！简单直接，<code>interface 抓老鼠 { void 抓老鼠();}</code> </p><p>​    只要实现这个接口，那么这只猫就拥有了自己独特的抓老鼠方法。</p><h5 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h5><p>​    继承<strong>抽象类</strong>是让某个类属于xxx的，如果继承了抽象类，那么该类就是这个抽象类一个种族的。</p><p>​    <strong>接口</strong>的实现让某个类 <strong>有</strong> xxx 方法</p><h5 id="接下来说一下他们俩的异同点"><a href="#接下来说一下他们俩的异同点" class="headerlink" title="接下来说一下他们俩的异同点"></a>接下来说一下他们俩的异同点</h5><ul><li>都不能被实例化！如果需要实例化，这就涉及到了 <a href="https://heronking.github.io/archives/f018dd97.html">多态</a>。</li><li>都能包含抽象方法。但是抽象类可以有实现的方法，甚至可以没有抽象方法。而接口里面必须都是抽象方法，不能实现。如果一个类里面有抽象方法，那么它一定是抽象类。</li><li>一个普通类可以实现多个接口，但是只能继承一个抽象类。</li><li>接口的方法默认是 <code>public</code>。抽象方法可以有 <code>public、protected 和 default</code>，不能是 <code>private</code>。</li><li>从设计层面上来说，抽象是对类的抽象，是一种模板的涉及，而接口是对行为的抽象，这是一种行为的规范。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记一些接口和抽象类的异同点&lt;br&gt;这两者本身的设计目的就是不一样的！我是直接从用法上理解的，设计完了用来干嘛，理解了也就知道了两者的异同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先理解一下什么是抽象类和接口&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://heronking.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="java" scheme="https://heronking.github.io/tags/java/"/>
    
      <category term="记" scheme="https://heronking.github.io/tags/%E8%AE%B0/"/>
    
  </entry>
  
</feed>
